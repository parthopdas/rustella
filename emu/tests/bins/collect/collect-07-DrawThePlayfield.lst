------- FILE D:\src\u\s\emu\tests\bins\collect\collect-07-DrawThePlayfield.asm LEVEL 1 PASS 2
      1  10000 ????						;===============================================================================
      2  10000 ????						; Program Information
      3  10000 ????						;===============================================================================
      4  10000 ????
      5  10000 ????						; Program:	 Collect
      6  10000 ????						; Program by:	 Darrell Spice, Jr
      7  10000 ????						; Last Update:  July 6, 2014
      8  10000 ????						;
      9  10000 ????						; Super simple game of "collect the boxes" used for presentation on
     10  10000 ????						; developing Atari 2600 homebrew games.
     11  10000 ????						;
     12  10000 ????						; See readme.txt for compile instructions
     13  10000 ????
     14  10000 ????
     15  10000 ????						;===============================================================================
     16  10000 ????						; Change Log
     17  10000 ????						;===============================================================================
     18  10000 ????
     19  10000 ????						; 2014.06.24 - generate a stable display
     20  10000 ????						; 2014.06.25 - add Score+1s
     21  10000 ????						; 2014.06.28 - add score display and check for TV Type
     22  10000 ????						; 2014.07.03 - add 2LK (2 line kernel)
     23  10000 ????						; 2014.07.04 - 2LK update, set VDELP0 and VDELP1 based on Y positions
     24  10000 ????						; 2014.07.04a- swapped GRP0 and GRP1 lines in the 2LK.  That gives us a
     25  10000 ????						;		possiblity of adding the BALL object
     26  10000 ????						;	      - changed Score+1 to be a bar across the screen so we can have
     27  10000 ????						;		a 2 player option
     28  10000 ????						; 2014.07.06 - Draw the Arena, playfield collision logic
     29  10000 ????
     30  10000 ????						;===============================================================================
     31  10000 ????						; Initialize dasm
     32  10000 ????						;===============================================================================
     33  10000 ????
     34  10000 ????						; Dasm supports a number of processors, this line tells dasm the code
     35  10000 ????						; is for the 6502 CPU.  The Atari has a 6507, which is 6502 that's been
     36  10000 ????						; put into a "reduced package".  This package limits the 6507 to an 8K
     37  10000 ????						; address space and also removes support for external interrupts.
     38  10000 ????				       PROCESSOR	6502
     39  10000 ????
     40  10000 ????						; vcs.h contains the standard definitions for TIA and RIOT registers
------- FILE vcs.h LEVEL 2 PASS 2
      0  10000 ????				       include	vcs.h
      1  10000 ????						; VCS.H
      2  10000 ????						; Version 1.06, 06/SEP/2020
      3  10000 ????
      4  10000 ????		00 6a	    VERSION_VCS =	106
      5  10000 ????
      6  10000 ????						; THIS IS *THE* "STANDARD" VCS.H
      7  10000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8  10000 ????						; The latest version can be found at https://dasm-assembler.github.io/
      9  10000 ????						;
     10  10000 ????						; This file defines hardware registers and memory mapping for the
     11  10000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     12  10000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     13  10000 ????						; available at at https://dasm-assembler.github.io/
     14  10000 ????						;
     15  10000 ????						; Many thanks to the people who have contributed. If you find an issue with the
     16  10000 ????						; contents, or would like ot add something, please report as an issue at...
     17  10000 ????						; https://github.com/dasm-assembler/dasm/issues
     18  10000 ????
     19  10000 ????						;
     20  10000 ????						; Latest Revisions...
     21  10000 ????						; 1.06  05/SEP/2020	 Modified header/license and links to new versions
     22  10000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     23  10000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     24  10000 ????						;			    This will allow conditional code to verify VCS.H being
     25  10000 ????						;			    used for code assembly.
     26  10000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     27  10000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     28  10000 ????						;			 mirrored reading/writing differences.	This is more a 
     29  10000 ????						;			 readability issue, and binary compatibility with disassembled
     30  10000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     31  10000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     32  10000 ????						;			 which was broken by the use of segments in this file, as
     33  10000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     34  10000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     35  10000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     36  10000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     37  10000 ????						;						   it is safe to leave it undefined, and the base address will
     38  10000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     39  10000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     40  10000 ????						;			  - register definitions are now generated through assignment
     41  10000 ????						;			    in uninitialised segments.	This allows a changeable base
     42  10000 ????						;			    address architecture.
     43  10000 ????						; 1.0	22/MAR/2003		Initial release
     44  10000 ????
     45  10000 ????
     46  10000 ????						;-------------------------------------------------------------------------------
     47  10000 ????
     48  10000 ????						; TIA_BASE_ADDRESS
     49  10000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     50  10000 ????						; Normally 0, the base address should (externally, before including this file)
     51  10000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     52  10000 ????						; The reason is that this bankswitching scheme treats any access to locations
     53  10000 ????						; < $40 as a bankswitch.
     54  10000 ????
     55  10000 ????			   -	       IFNCONST	TIA_BASE_ADDRESS
     56  10000 ????			   -TIA_BASE_ADDRESS =	0
     57  10000 ????				       ENDIF
     58  10000 ????
     59  10000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     60  10000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     61  10000 ????						; *OR* by declaring the label before including this file, eg:
     62  10000 ????						; TIA_BASE_ADDRESS = $40
     63  10000 ????						;   include "vcs.h"
     64  10000 ????
     65  10000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     66  10000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     67  10000 ????						; for the mirrored ROM hardware registers.
     68  10000 ????
     69  10000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     70  10000 ????						; using the -D command-line switch, as required.  If the addresses are not defined, 
     71  10000 ????						; they defaut to the TIA_BASE_ADDRESS.
     72  10000 ????
     73  10000 ????			   -	       IFNCONST	TIA_BASE_READ_ADDRESS
     74  10000 ????			   -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     75  10000 ????				       ENDIF
     76  10000 ????
     77  10000 ????			   -	       IFNCONST	TIA_BASE_WRITE_ADDRESS
     78  10000 ????			   -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     79  10000 ????				       ENDIF
     80  10000 ????
     81  10000 ????						;-------------------------------------------------------------------------------
     82  10000 ????
     83 U002d ????				      SEG.U	TIA_REGISTERS_WRITE
     84 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     85 U0000
     86 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     87 U0000
     88 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     89 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     90 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     91 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     92 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     93 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     94 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     95 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     96 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     97 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     98 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     99 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    100 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    101 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    102 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    103 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    104 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    105 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    106 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    107 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    108 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    109 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    110 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    111 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    112 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    113 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    114 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    115 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    116 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    117 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    118 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    119 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    120 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    121 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    122 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    123 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    124 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    125 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    126 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    127 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    128 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    129 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    130 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    131 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    132 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    133 U002d
    134 U002d							;-------------------------------------------------------------------------------
    135 U002d
    136 U000e ????				      SEG.U	TIA_REGISTERS_READ
    137 U0000					      ORG	TIA_BASE_READ_ADDRESS
    138 U0000
    139 U0000							;											bit 7	 bit 6
    140 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    141 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    142 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    143 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    144 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    145 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    146 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    147 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    148 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    149 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    150 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    151 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    152 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    153 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    154 U000e
    155 U000e							;-------------------------------------------------------------------------------
    156 U000e
    157 U0298 ????				      SEG.U	RIOT
    158 U0280					      ORG	$280
    159 U0280
    160 U0280							; RIOT MEMORY MAP
    161 U0280
    162 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    163 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    164 U0281
    165 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    166 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    167 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    168 U0284		       00	   INTIM      ds	1	; $284		Timer output
    169 U0285
    170 U0285		       00	   TIMINT     ds	1	; $285
    171 U0286
    172 U0286							; Unused/undefined registers ($285-$294)
    173 U0286
    174 U0286		       00		      ds	1	; $286
    175 U0287		       00		      ds	1	; $287
    176 U0288		       00		      ds	1	; $288
    177 U0289		       00		      ds	1	; $289
    178 U028a		       00		      ds	1	; $28A
    179 U028b		       00		      ds	1	; $28B
    180 U028c		       00		      ds	1	; $28C
    181 U028d		       00		      ds	1	; $28D
    182 U028e		       00		      ds	1	; $28E
    183 U028f		       00		      ds	1	; $28F
    184 U0290		       00		      ds	1	; $290
    185 U0291		       00		      ds	1	; $291
    186 U0292		       00		      ds	1	; $292
    187 U0293		       00		      ds	1	; $293
    188 U0294
    189 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    190 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    191 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    192 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    193 U0298
    194 U0298							;-------------------------------------------------------------------------------
    195 U0298							; The following required for back-compatibility with code which does not use
    196 U0298							; segments.
    197 U0298
    198  0000 ????				      SEG
    199  0000 ????
    200  0000 ????						; EOF
------- FILE D:\src\u\s\emu\tests\bins\collect\collect-07-DrawThePlayfield.asm
     42  0000 ????
     43  0000 ????						; macro.h contains commonly used routines which aid in coding
------- FILE macro.h LEVEL 2 PASS 2
      0  0000 ????				      include	macro.h
      1  0000 ????						; MACRO.H
      2  0000 ????						; Version 1.09, 05/SEP/2020
      3  0000 ????
      4  0000 ????	       00 6d	   VERSION_MACRO =	109
      5  0000 ????
      6  0000 ????						;
      7  0000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8  0000 ????						; The latest version can be found at https://dasm-assembler.github.io/
      9  0000 ????						;
     10  0000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     11  0000 ????						; It is distributed as a companion machine-specific support package
     12  0000 ????						; for the DASM compiler.
     13  0000 ????						;
     14  0000 ????						; Many thanks to the people who have contributed. If you find an issue with the
     15  0000 ????						; contents, or would like ot add something, please report as an issue at...
     16  0000 ????						; https://github.com/dasm-assembler/dasm/issues
     17  0000 ????
     18  0000 ????
     19  0000 ????						; Latest Revisions...
     20  0000 ????						; 1.09  05/SEP/2020	 - updated license/links
     21  0000 ????
     22  0000 ????						; 1.08  13/JUL/2020	 - added use of LXA to CLEAN_START
     23  0000 ????						; 1.07  19/JAN/2020	 - correction to comment VERTICAL_SYNC
     24  0000 ????						; 1.06  03/SEP/2004	 - nice revision of VERTICAL_SYNC (Edwin Blink)
     25  0000 ????						; 1.05  14/NOV/2003	 - Added VERSION_MACRO equate (which will reflect 100x version #)
     26  0000 ????						;			   This will allow conditional code to verify MACRO.H being
     27  0000 ????						;			   used for code assembly.
     28  0000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     29  0000 ????						;
     30  0000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     31  0000 ????						;
     32  0000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     33  0000 ????						;			   (standardised macro for vertical synch code)
     34  0000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added. 
     35  0000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     36  0000 ????						; 1.0	22/MAR/2003		Initial release
     37  0000 ????
     38  0000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage, 
     39  0000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     40  0000 ????						;   If you do not allow illegal opcode usage, you must include this file 
     41  0000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     42  0000 ????						;   registers and require them to be defined first).
     43  0000 ????
     44  0000 ????						; Available macros...
     45  0000 ????						;   SLEEP n		 - sleep for n cycles
     46  0000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     47  0000 ????						;   CLEAN_START	 - set machine to known state on startup
     48  0000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     49  0000 ????
     50  0000 ????						;-------------------------------------------------------------------------------
     51  0000 ????						; SLEEP duration
     52  0000 ????						; Original author: Thomas Jentzsch
     53  0000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     54  0000 ????						; useful for code where precise timing is required.
     55  0000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     56  0000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     57  0000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     58  0000 ????
     59  0000 ????				      MAC	sleep
     60  0000 ????			   .CYCLES    SET	{1}
     61  0000 ????
     62  0000 ????				      IF	.CYCLES < 2
     63  0000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     64  0000 ????				      ERR
     65  0000 ????				      ENDIF
     66  0000 ????
     67  0000 ????				      IF	.CYCLES & 1
     68  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     69  0000 ????				      nop	0
     70  0000 ????				      ELSE
     71  0000 ????				      bit	VSYNC
     72  0000 ????				      ENDIF
     73  0000 ????			   .CYCLES    SET	.CYCLES - 3
     74  0000 ????				      ENDIF
     75  0000 ????
     76  0000 ????				      REPEAT	.CYCLES / 2
     77  0000 ????				      nop
     78  0000 ????				      REPEND
     79  0000 ????				      ENDM		;usage: SLEEP n (n>1)
     80  0000 ????
     81  0000 ????						;-------------------------------------------------------------------------------
     82  0000 ????						; VERTICAL_SYNC
     83  0000 ????						; revised version by Edwin Blink -- saves bytes!
     84  0000 ????						; Inserts the code required for a proper 3 scanline vertical sync sequence
     85  0000 ????						; Note: Alters the accumulator
     86  0000 ????
     87  0000 ????						; OUT: A = 0
     88  0000 ????
     89  0000 ????				      MAC	vertical_sync
     90  0000 ????				      lda	#%1110	; each '1' bits generate a VSYNC ON line (bits 1..3)
     91  0000 ????			   .VSLP1     sta	WSYNC	; 1st '0' bit resets Vsync, 2nd '0' bit exit loop
     92  0000 ????				      sta	VSYNC
     93  0000 ????				      lsr
     94  0000 ????				      bne	.VSLP1	; branch until VYSNC has been reset
     95  0000 ????				      ENDM
     96  0000 ????
     97  0000 ????						;-------------------------------------------------------------------------------
     98  0000 ????						; CLEAN_START
     99  0000 ????						; Original author: Andrew Davie
    100  0000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
    101  0000 ????						; Sets stack pointer to $FF, and all registers to 0
    102  0000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    103  0000 ????						; Use as very first section of code on boot (ie: at reset)
    104  0000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    105  0000 ????
    106  0000 ????				      MAC	clean_start
    107  0000 ????				      sei
    108  0000 ????				      cld
    109  0000 ????
    110  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
    111  0000 ????				      lxa	#0
    112  0000 ????				      ELSE
    113  0000 ????				      ldx	#0
    114  0000 ????				      txa
    115  0000 ????				      ENDIF
    116  0000 ????				      tay
    117  0000 ????			   .CLEAR_STACK dex
    118  0000 ????				      txs
    119  0000 ????				      pha
    120  0000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    121  0000 ????
    122  0000 ????				      ENDM
    123  0000 ????
    124  0000 ????						;-------------------------------------------------------
    125  0000 ????						; SET_POINTER
    126  0000 ????						; Original author: Manuel Rotschkar
    127  0000 ????						;
    128  0000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    129  0000 ????						;
    130  0000 ????						; Usage: SET_POINTER pointer, address
    131  0000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    132  0000 ????						;
    133  0000 ????						; Note: Alters the accumulator, NZ flags
    134  0000 ????						; IN 1: 2 byte RAM location reserved for pointer
    135  0000 ????						; IN 2: absolute address
    136  0000 ????
    137  0000 ????				      MAC	set_pointer
    138  0000 ????			   .POINTER   SET	{1}
    139  0000 ????			   .ADDRESS   SET	{2}
    140  0000 ????
    141  0000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    142  0000 ????				      STA	.POINTER	; Store in pointer
    143  0000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    144  0000 ????				      STA	.POINTER+1	; Store in pointer+1
    145  0000 ????
    146  0000 ????				      ENDM
    147  0000 ????
    148  0000 ????						;-------------------------------------------------------
    149  0000 ????						; BOUNDARY byte#
    150  0000 ????						; Original author: Denis Debro (borrowed from Bob Smith / Thomas)
    151  0000 ????						;
    152  0000 ????						; Push data to a certain position inside a page and keep count of how
    153  0000 ????						; many free bytes the programmer will have.
    154  0000 ????						;
    155  0000 ????						; eg: BOUNDARY 5    ; position at byte #5 in page
    156  0000 ????
    157  0000 ????			   .FREE_BYTES SET	0
    158  0000 ????				      MAC	boundary
    159  0000 ????				      REPEAT	256
    160  0000 ????				      IF	<. % {1} = 0
    161  0000 ????				      MEXIT
    162  0000 ????				      ELSE
    163  0000 ????			   .FREE_BYTES SET	.FREE_BYTES + 1
    164  0000 ????				      .byte	$00
    165  0000 ????				      ENDIF
    166  0000 ????				      REPEND
    167  0000 ????				      ENDM
    168  0000 ????
    169  0000 ????
    170  0000 ????						; EOF
------- FILE D:\src\u\s\emu\tests\bins\collect\collect-07-DrawThePlayfield.asm
     45  0000 ????
     46  0000 ????						;===============================================================================
     47  0000 ????						; Define Constants
     48  0000 ????						;===============================================================================
     49  0000 ????						; height of the arena (gameplay area).  Since we're using a 2 line kernel,
     50  0000 ????						; actual height will be twice this.  Also, we're using 0-89 for the
     51  0000 ????						; scanlines so actual height is 176 = 88*2
     52  0000 ????	       00 57	   ARENA_HEIGHT =	87
     53  0000 ????
     54  0000 ????						;===============================================================================
     55  0000 ????						; Define RAM Usage
     56  0000 ????						;===============================================================================
     57  0000 ????
     58  0000 ????						; define a segment for variables
     59  0000 ????						; .U means uninitialized, does not end up in ROM
     60 U00a5 ????				      SEG.U	VARS
     61 U00a5 ????
     62 U00a5 ????						; RAM starts at $80
     63 U0080					      ORG	$80
     64 U0080
     65 U0080							; Holds 2 digit score for each player, stored as BCD (Binary Coded Decimal)
     66 U0080		       00 00	   Score      ds	2	; stored in $80-81
     67 U0082
     68 U0082
     69 U0082							; Offsets into digit graphic data
     70 U0082		       00 00	   DigitOnes  ds	2	; stored in $82-83, DigitOnes = Score, DigitOnes+1 = Score+1
     71 U0084		       00 00	   DigitTens  ds	2	; stored in $84-85, DigitTens = Score, DigitTens+1 = Score+1
     72 U0086
     73 U0086							; graphic data ready to put into PF1 during display score routine
     74 U0086		       00 00	   ScoreGfx   ds	2	; stored in $86-87
     75 U0088
     76 U0088							; scratch variable
     77 U0088		       00	   Temp       ds	1	; stored in $88
     78 U0089
     79 U0089							; object X positions in $89-8D
     80 U0089		       00 00 00 00*ObjectX    ds	5	; player0, player1, missile0, missile1, ball
     81 U008e
     82 U008e							; object Y positions in $8E-92
     83 U008e		       00 00 00 00*ObjectY    ds	5	; player0, player1, missile0, missile1, ball
     84 U0093
     85 U0093							; DoDraw storage in $93-94
     86 U0093		       00	   Player0Draw ds	1	; used for drawing player0
     87 U0094		       00	   Player1Draw ds	1	; used for drawing player1
     88 U0095
     89 U0095							; DoDraw Graphic Pointers in $95-98
     90 U0095		       00 00	   Player0Ptr ds	2	; used for drawing player0
     91 U0097		       00 00	   Player1Ptr ds	2	; used for drawing player1
     92 U0099
     93 U0099							; frame counter
     94 U0099		       00	   Frame      ds	1	; stored in $99
     95 U009a
     96 U009a		       00 00 00 00*TimerPF    ds	6	; stored in $9A-9F
     97 U00a0		       00	   ArenaColor ds	1	; stored in $A0
     98 U00a1
     99 U00a1							;save player locations for playfield collision logic
    100 U00a1		       00 00	   SavedX     ds	2	; stored in $A1-A2
    101 U00a3		       00 00	   SavedY     ds	2	; stored in $A3-A4
    102 U00a5
    103 U00a5							;===============================================================================
    104 U00a5							; Define Start of Cartridge
    105 U00a5							;===============================================================================
    106 U00a5
    107 U00a5							; define a segment for code
    108  10000 ????				       SEG	CODE
    109  10000 ????
    110  10000 ????						; 2K ROM starts at $F800, 4K ROM starts at $F000
    111  f800					      ORG	$F800
    112  f800
    113  f800							;===============================================================================
    114  f800							; PosObject
    115  f800							;----------
    116  f800							; subroutine for setting the X position of any TIA object
    117  f800							; when called, set the following registers:
    118  f800							;   A - holds the X position of the object
    119  f800							;   X - holds which object to position
    120  f800							;	 0 = player0
    121  f800							;	 1 = player1
    122  f800							;	 2 = missile0
    123  f800							;	 3 = missile1
    124  f800							;	 4 = ball
    125  f800							; the routine will set the coarse X position of the object, as well as the
    126  f800							; fine-tune register that will be used when HMOVE is used.
    127  f800							;===============================================================================
    128  f800				   PosObject
    129  f800		       38		      sec
    130  f801		       85 02		      sta	WSYNC
    131  f803				   DivideLoop
    132  f803		       e9 0f		      sbc	#15	; 2  2 - each time thru this loop takes 5 cycles, which is
    133  f805		       b0 fc		      bcs	DivideLoop	; 2  4 - the same amount of time it takes to draw 15 pixels
    134  f807		       49 07		      eor	#7	; 2  6 - The EOR & ASL statements convert the remainder
    135  f809		       0a		      asl		; 2  8 - of position/15 to the value needed to fine tune
    136  f80a		       0a		      asl		; 2 10 - the X position
    137  f80b		       0a		      asl		; 2 12
    138  f80c		       0a		      asl		; 2 14
    139  f80d		       9d 20 00 	      sta.wx	HMP0,X	; 5 19 - store fine tuning of X
    140  f810		       95 10		      sta	RESP0,X	; 4 23 - set coarse X position of object
    141  f812		       60		      rts		; 6 29
    142  f813
    143  f813
    144  f813							;===============================================================================
    145  f813							; Initialize Atari
    146  f813							;===============================================================================
    147  f813
    148  f813				   InitSystem
    149  f813							; CLEAN_START is a macro found in macro.h
    150  f813							; it sets all RAM, TIA registers and CPU registers to 0
      0  f813					      CLEAN_START
      1  f813		       78		      sei
      2  f814		       d8		      cld
      3  f815
      4  f815				  -	      IFNCONST	NO_ILLEGAL_OPCODES
      5  f815				  -	      lxa	#0
      6  f815					      ELSE
      7  f815		       a2 00		      ldx	#0
      8  f817		       8a		      txa
      9  f818					      ENDIF
     10  f818		       a8		      tay
     11  f819		       ca	   .CLEAR_STACK dex
     12  f81a		       9a		      txs
     13  f81b		       48		      pha
     14  f81c		       d0 fb		      bne	.CLEAR_STACK
     15  f81e
    152  f81e
    153  f81e							; set starting location of player0 and player1 objects
    154  f81e		       a2 0a		      ldx	#10
    155  f820		       86 89		      stx	ObjectX
    156  f822		       86 0c		      stx	REFP1	; bit D3 is on, so reflect player1
    157  f824		       a2 8e		      ldx	#142
    158  f826		       86 8a		      stx	ObjectX+1
    159  f828		       a2 63		      ldx	#$63
    160  f82a		       86 8e		      stx	ObjectY
    161  f82c		       86 8f		      stx	ObjectY+1
    162  f82e							; from here we "fall into" the main loop
    163  f82e
    164  f82e							;===============================================================================
    165  f82e							; Main Program Loop
    166  f82e							;===============================================================================
    167  f82e
    168  f82e				   Main
    169  f82e		       20 3d f8 	      jsr	VerticalSync	; Jump to SubRoutine VerticalSync
    170  f831		       20 69 f8 	      jsr	VerticalBlank	; Jump to SubRoutine VerticalBlank
    171  f834		       20 79 f8 	      jsr	Kernel	; Jump to SubRoutine Kernel
    172  f837		       20 61 f9 	      jsr	OverScan	; Jump to SubRoutine OverScan
    173  f83a		       4c 2e f8 	      jmp	Main	; JuMP to Main
    174  f83d
    175  f83d
    176  f83d							;===============================================================================
    177  f83d							; Vertical Sync
    178  f83d							; -------------
    179  f83d							; here we generate the signal that tells the TV to move the beam to the top of
    180  f83d							; the screen so we can start the next frame of video.
    181  f83d							; The Sync Signal must be on for 3 scanlines.
    182  f83d							;===============================================================================
    183  f83d
    184  f83d				   VerticalSync
    185  f83d		       a9 02		      lda	#2	; LoaD Accumulator with 2 so D1=1
    186  f83f		       a2 31		      ldx	#49	; LoaD X with 49
    187  f841		       85 02		      sta	WSYNC	; Wait for SYNC (halts CPU until end of scanline)
    188  f843		       85 00		      sta	VSYNC	; Accumulator D1=1, turns on Vertical Sync signal
    189  f845		       8e 96 02 	      stx	TIM64T	; set Score+1 to go off in 41 scanlines (49 * 64) / 76
    190  f848		       85 0a		      sta	CTRLPF	; D1=1, playfield now in SCORE mode
    191  f84a		       e6 99		      inc	Frame	; increment Frame count
    192  f84c		       85 02		      sta	WSYNC	; Wait for Sync - halts CPU until end of 1st scanline of VSYNC
    193  f84e		       85 02		      sta	WSYNC	; wait until end of 2nd scanline of VSYNC
    194  f850		       a9 00		      lda	#0	; LoaD Accumulator with 0 so D1=0
    195  f852		       85 0d		      sta	PF0	; blank the playfield
    196  f854		       85 0e		      sta	PF1	; blank the playfield
    197  f856		       85 0f		      sta	PF2	; blank the playfield
    198  f858		       85 1b		      sta	GRP0	; blanks player0 if VDELP0 was off
    199  f85a		       85 1c		      sta	GRP1	; blanks player0 if VDELP0 was on, player1 if VDELP1 was off
    200  f85c		       85 1b		      sta	GRP0	; blanks			    player1 if VDELP1 was on
    201  f85e		       85 25		      sta	VDELP0	; turn off Vertical Delay
    202  f860		       85 26		      sta	VDELP1	; turn off Vertical Delay
    203  f862		       85 2c		      sta	CXCLR	; clear collision detection latches
    204  f864		       85 02		      sta	WSYNC	; wait until end of 3rd scanline of VSYNC
    205  f866		       85 00		      sta	VSYNC	; Accumulator D1=0, turns off Vertical Sync signal
    206  f868				   Sleep12		;	 jsr here to sleep for 12 cycles
    207  f868		       60		      rts		; ReTurn from Subroutine
    208  f869
    209  f869
    210  f869							;===============================================================================
    211  f869							; Vertical Blank
    212  f869							; --------------
    213  f869							; game logic runs here.
    214  f869							;===============================================================================
    215  f869
    216  f869				   VerticalBlank
    217  f869		       20 8c f9 	      jsr	UpdateTimer
    218  f86c		       20 bb f9 	      jsr	ProcessJoystick
    219  f86f		       20 22 fa 	      jsr	PositionObjects
    220  f872		       20 7f fa 	      jsr	SetObjectColors
    221  f875		       20 a5 fa 	      jsr	PrepScoreForDisplay
    222  f878		       60		      rts		; ReTurn from Subroutine
    223  f879
    224  f879
    225  f879							;===============================================================================
    226  f879							; Kernel
    227  f879							; ------
    228  f879							; here we update the registers in TIA, the video chip, scanline by scanline
    229  f879							; in order to generate what the player sees.
    230  f879							;
    231  f879							; Timing is crucial in the kernel, so we need to count the cycles.  You may
    232  f879							; use your own method of counting cycles, this is how I do it:
    233  f879							;	 instruction	 ;xx yy - comment
    234  f879							;   xx = cycles instruction will take
    235  f879							;   yy = cumulative cycle count after instruction runs
    236  f879							;   comment = what's going on.  Some instructions have special notation:
    237  f879							;	 @aa-bb where aa and bb are numbers.  These are used to denote that the
    238  f879							;	     instruction MUST be done within a range of cycles.  This is especially
    239  f879							;	     true of updating the playfield where you need to update the register
    240  f879							;	     twice on a scanline if you want the left and right side of the screen
    241  f879							;	     to show different images.	If aa > bb that means the instruction can
    242  f879							;	     be executed on the prior scanline on or after cycle aa.
    243  f879							;	 (a b) where a and b are numbers.  These are used for branches to show
    244  f879							;	     the cycles and cycle count if the branch is taken.
    245  f879							;
    246  f879							; The following is used to denote when a new scanline starts:
    247  f879							;---------------------------------------
    248  f879							;
    249  f879							;===============================================================================
    250  f879
    251  f879				   Kernel
    252  f879		       85 02		      sta	WSYNC	; Wait for SYNC (halts CPU until end of scanline)
    253  f87b							;---------------------------------------
    254  f87b		       ad 84 02 	      lda	INTIM	; 4  4 - check the Score+1
    255  f87e		       d0 f9		      bne	Kernel	; 2  6 - (3 7) Branch if its Not Equal to 0
    256  f880							; turn on the display
    257  f880		       85 01		      sta	VBLANK	; 3  9 - Accumulator D1=0, turns off Vertical Blank signal (image output on)
    258  f882		       a2 05		      ldx	#5	; 2 11 - use X as the loop counter for ScoreLoop
    259  f884
    260  f884							; first thing we draw is the score.  Score is drawn using only PF1 of the
    261  f884							; playfield.  The playfield is set for in repeat mode, and SCORE is turned
    262  f884							; on so the left and right sides take on the colors of player0 and player1.
    263  f884							; To get here we can fall thru from above (cycle 11) OR loop back from below
    264  f884							; (cycle 43). We'll cycle count from the worst case scenario
    265  f884				   ScoreLoop		;   43 - cycle after bpl ScoreLoop
    266  f884		       a4 84		      ldy	DigitTens	; 3 46 - get the tens digit offset for the Score
    267  f886		       b9 00 fb 	      lda	DigitGfx,y	; 5 51 -   use it to load the digit graphics
    268  f889		       29 f0		      and	#$F0	; 2 53 -   remove the graphics for the ones digit
    269  f88b		       85 86		      sta	ScoreGfx	; 3 56 -   and save it
    270  f88d		       a4 82		      ldy	DigitOnes	; 3 59 - get the ones digit offset for the Score
    271  f88f		       b9 00 fb 	      lda	DigitGfx,y	; 5 64 -   use it to load the digit graphics
    272  f892		       29 0f		      and	#$0F	; 2 66 -   remove the graphics for the tens digit
    273  f894		       05 86		      ora	ScoreGfx	; 3 69 -   merge with the tens digit graphics
    274  f896		       85 86		      sta	ScoreGfx	; 3 72 -   and save it
    275  f898		       85 02		      sta	WSYNC	; 3 75 - wait for end of scanline
    276  f89a							;---------------------------------------
    277  f89a		       85 0e		      sta	PF1	; 3  3 - @66-28, update playfield for Score dislay
    278  f89c		       a4 85		      ldy	DigitTens+1	; 3  6 - get the left digit offset for the Score+1
    279  f89e		       b9 00 fb 	      lda	DigitGfx,y	; 5 11 -   use it to load the digit graphics
    280  f8a1		       29 f0		      and	#$F0	; 2 13 -   remove the graphics for the ones digit
    281  f8a3		       85 87		      sta	ScoreGfx+1	; 3 16 -   and save it
    282  f8a5		       a4 83		      ldy	DigitOnes+1	; 3 19 - get the ones digit offset for the Score+1
    283  f8a7		       b9 00 fb 	      lda	DigitGfx,y	; 5 24 -   use it to load the digit graphics
    284  f8aa		       29 0f		      and	#$0F	; 2 26 -   remove the graphics for the tens digit
    285  f8ac		       05 87		      ora	ScoreGfx+1	; 3 29 -   merge with the tens digit graphics
    286  f8ae		       85 87		      sta	ScoreGfx+1	; 3 32 -   and save it
    287  f8b0		       20 68 f8 	      jsr	Sleep12	;12 44 - waste some cycles
    288  f8b3		       85 0e		      sta	PF1	; 3 47 - @39-54, update playfield for Score+1 display
    289  f8b5		       a4 86		      ldy	ScoreGfx	; 3 50 - preload for next scanline
    290  f8b7		       85 02		      sta	WSYNC	; 3 53 - wait for end of scanline
    291  f8b9							;---------------------------------------
    292  f8b9		       84 0e		      sty	PF1	; 3  3 - update playfield for the Score display
    293  f8bb		       e6 84		      inc	DigitTens	; 5  8 - advance for the next line of graphic data
    294  f8bd		       e6 85		      inc	DigitTens+1	; 5 13 - advance for the next line of graphic data
    295  f8bf		       e6 82		      inc	DigitOnes	; 5 18 - advance for the next line of graphic data
    296  f8c1		       e6 83		      inc	DigitOnes+1	; 5 23 - advance for the next line of graphic data
    297  f8c3		       20 68 f8 	      jsr	Sleep12	;12 35 - waste some cycles
    298  f8c6		       ca		      dex		; 2 37 - decrease the loop counter
    299  f8c7		       85 0e		      sta	PF1	; 3 40 - @39-54, update playfield for the Score+1 display
    300  f8c9		       d0 b9		      bne	ScoreLoop	; 2 42 - (3 43) if dex != 0 then branch to ScoreLoop
    301  f8cb		       85 02		      sta	WSYNC	; 3 45 - wait for end of scanline
    302  f8cd							;---------------------------------------
    303  f8cd		       86 0e		      stx	PF1	; 3  3 - x = 0, so this blanks out playfield
    304  f8cf		       85 02		      sta	WSYNC	; 3  6 - wait for end of scanline
    305  f8d1							;---------------------------------------
    306  f8d1		       a9 00		      lda	#0	; 2  2
    307  f8d3		       85 0a		      sta	CTRLPF	; 3  5 - turn off SCORE mode
    308  f8d5		       a2 01		      ldx	#1	; 2  7
    309  f8d7							; draw timer bar
    310  f8d7				   TimerBar
    311  f8d7		       85 02		      sta	WSYNC	; 3
    312  f8d9							;---------------------------------------
    313  f8d9		       a5 9a		      lda	TimerPF	; 3  3
    314  f8db		       85 0d		      sta	PF0	; 3  6
    315  f8dd		       a5 9b		      lda	TimerPF+1	; 3  9
    316  f8df		       85 0e		      sta	PF1	; 3 12
    317  f8e1		       a5 9c		      lda	TimerPF+2	; 3 15
    318  f8e3		       85 0f		      sta	PF2	; 3 18
      0  f8e5					      SLEEP	20	;20 38
      1  f8e5				   .CYCLES    SET	20
      2  f8e5
      3  f8e5				  -	      IF	.CYCLES < 2
      4  f8e5				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f8e5				  -	      ERR
      6  f8e5					      ENDIF
      7  f8e5
      8  f8e5				  -	      IF	.CYCLES & 1
      9  f8e5				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  f8e5				  -	      nop	0
     11  f8e5				  -	      ELSE
     12  f8e5				  -	      bit	VSYNC
     13  f8e5				  -	      ENDIF
     14  f8e5				  -.CYCLES    SET	.CYCLES - 3
     15  f8e5					      ENDIF
     16  f8e5
     17  f8e5					      REPEAT	.CYCLES / 2
     18  f8e5		       ea		      nop
     17  f8e5					      REPEND
     18  f8e6		       ea		      nop
     17  f8e6					      REPEND
     18  f8e7		       ea		      nop
     17  f8e7					      REPEND
     18  f8e8		       ea		      nop
     17  f8e8					      REPEND
     18  f8e9		       ea		      nop
     17  f8e9					      REPEND
     18  f8ea		       ea		      nop
     17  f8ea					      REPEND
     18  f8eb		       ea		      nop
     17  f8eb					      REPEND
     18  f8ec		       ea		      nop
     17  f8ec					      REPEND
     18  f8ed		       ea		      nop
     17  f8ed					      REPEND
     18  f8ee		       ea		      nop
     19  f8ef					      REPEND
    320  f8ef		       a5 9d		      lda	TimerPF+3	; 3 41
    321  f8f1		       85 0d		      sta	PF0	; 3 44
    322  f8f3		       a5 9e		      lda	TimerPF+4	; 3 47
    323  f8f5		       85 0e		      sta	PF1	; 3 50
    324  f8f7		       a5 9f		      lda	TimerPF+5	; 3 53
    325  f8f9		       85 0f		      sta	PF2	; 3 56
    326  f8fb		       ca		      dex		; 2 58
    327  f8fc		       10 d9		      bpl	TimerBar	; 2 60 (3 61)
    328  f8fe		       85 02		      sta	WSYNC	; 3 63
    329  f900							;---------------------------------------
    330  f900		       a9 00		      lda	#0	; 2  2
    331  f902		       85 0d		      sta	PF0	; 3  5
    332  f904		       85 0e		      sta	PF1	; 3  8
    333  f906		       85 0f		      sta	PF2	; 3 11
    334  f908		       a5 a0		      lda	ArenaColor	; 3 14
    335  f90a		       85 08		      sta	COLUPF	; 3 17
    336  f90c		       85 02		      sta	WSYNC	; 3 20 - gab between timer and Arena
    337  f90e							;---------------------------------------
    338  f90e
    339  f90e
    340  f90e							; The Arena is drawn using what is known as a 2 line kernel, or 2LK for
    341  f90e							; short. Basically the code is designed so that the TIA register updates are
    342  f90e							; spread out over 2 scanlines instead of one.	TIA has a feature for the
    343  f90e							; player objects, as well as the ball, called Vertical Delay which allows
    344  f90e							; the objects to still start on any scanline even though they are only
    345  f90e							; updated every-other scanline.  Vertical Delay is controlled by the TIA
    346  f90e							; registers VDELP0, VDELP1 and VDELBL.
    347  f90e							;
    348  f90e							; ArenaLoop:
    349  f90e							;	 line 1 - updates player0, playfield
    350  f90e							;	 line 2 - updates player1, playfield
    351  f90e							;	 if not at bottom, goto ArenaLoop
    352  f90e
    353  f90e							; we need to preload GRP1 so that player1 can appear on the very first
    354  f90e							; scanline of the Arena
    355  f90e
    356  f90e		       a9 01		      lda	#1	; 2  2
    357  f910		       85 0a		      sta	CTRLPF	; 3  5 - turn off SCORE mode and turn on REFLECT
    358  f912		       a0 58		      ldy	#ARENA_HEIGHT+1	; 2  7 - the arena will be 180 scanlines (from 0-89)*2
    359  f914		       a2 00		      ldx	#0	; 2  9 - used for drawing playfield
    360  f916
    361  f916							; prime GRP1 so player1 can appear on topmost scanline of the Arena
    362  f916		       a9 09		      lda	#HUMAN_HEIGHT-1	; 2  9 - height of player0 graphics,
    363  f918		       c7 93		      dcp	Player0Draw	; 5 14 - Decrement Player0Draw and compare with height
    364  f91a		       b0 03		      bcs	DoDrawGrp0pre	; 2 16 - (3 17) if Carry is Set, then player0 is on current scanline
    365  f91c		       a9 00		      lda	#0	; 2 18 - otherwise use 0 to turn off player0
    366  f91e		       2c		      .byte.b	$2C	; 4 22 - $2C = BIT with absolute addressing, trick that
    367  f91f							;	  causes the lda (Player0Ptr),y to be skipped
    368  f91f				   DoDrawGrp0pre		;   17 - from bcs DoDrawGRP0pre
    369  f91f		       b1 95		      lda	(Player0Ptr),y	; 5 22 - load the shape for player0
    370  f921		       85 1b		      sta	GRP0	; 3 25 - @0-22, update player0 graphics
    371  f923		       88		      dey		; 2 27
    372  f924
    373  f924				   ArenaLoop		;   27 - (currently 7 from bpl ArenaLoop)
    374  f924		       98		      tya		; 2 29 - 2LK loop counter in A for testing
    375  f925		       29 03		      and	#%11	; 2 31 - test for every 4th time through the loop,
    376  f927		       d0 01		      bne	SkipX	; 2 33 (3 34) branch if not 4th time
    377  f929		       e8		      inx		; 2 35 - if 4th time, increase X so new playfield data is used
    378  f92a				   SkipX		;   35 - use 35 as it's the longest path here
    379  f92a
    380  f92a							; continuation of line 2 of the 2LK
    381  f92a							; this precalculates data that's used on line 1 of the 2LK
    382  f92a		       a9 09		      lda	#HUMAN_HEIGHT-1	; 2 37 - height of the humanoid graphics, subtract 1 due to starting with 0
    383  f92c		       c7 94		      dcp	Player1Draw	; 5 42 - Decrement Player1Draw and compare with height
    384  f92e		       b0 03		      bcs	DoDrawGrp1	; 2 44 - (3 45) if Carry is Set, then player1 is on current scanline
    385  f930		       a9 00		      lda	#0	; 2 46 - otherwise use 0 to turn off player1
    386  f932		       2c		      .byte.b	$2C	; 4 50 - $2C = BIT with absolute addressing, trick that
    387  f933							;	  causes the lda (Player1Ptr),y to be skipped
    388  f933				   DoDrawGrp1		;   45 - from bcs DoDrawGrp1
    389  f933		       b1 97		      lda	(Player1Ptr),y	; 5 50 - load the shape for player1
    390  f935		       85 02		      sta	WSYNC	; 3 53
    391  f937							;---------------------------------------
    392  f937							; start of line 1 of the 2LK
    393  f937		       85 1c		      sta	GRP1	; 3  3 - @0-22, update player1 graphics
    394  f939		       bd 64 fb 	      lda	ArenaPF0,x	; 4  7 - get current scanline's playfield pattern
    395  f93c		       85 0d		      sta	PF0	; 3 10 - @0-22 and update it
    396  f93e		       bd 7a fb 	      lda	ArenaPF1,x	; 4 14 - get current scanline's playfield pattern
    397  f941		       85 0e		      sta	PF1	; 3 17 - @71-28 and update it
    398  f943		       bd 90 fb 	      lda	ArenaPF2,x	; 4 21 - get current scanline's playfield pattern
    399  f946		       85 0f		      sta	PF2	; 3 24 - @60-39
    400  f948
    401  f948							; precalculate data that's needed for line 2 of the 2LK
    402  f948		       a9 09		      lda	#HUMAN_HEIGHT-1	; 2 26 - height of the box graphics,
    403  f94a		       c7 93		      dcp	Player0Draw	; 5 31 - Decrement Player0Draw and compare with height
    404  f94c		       b0 03		      bcs	DoDrawGrp0	; 2 33 - (3 34) if Carry is Set then player0 is on current scanline
    405  f94e		       a9 00		      lda	#0	; 2 35 - otherwise use 0 to turn off player0
    406  f950		       2c		      .byte.b	$2C	; 4 39 - $2C = BIT with absolute addressing, trick that
    407  f951							;	  causes the lda (Player0Ptr),y to be skipped
    408  f951				   DoDrawGrp0		;   34 - from bcs DoDrawGRP0
    409  f951		       b1 95		      lda	(Player0Ptr),y	; 5 39 - load the shape for player0
    410  f953		       85 02		      sta	WSYNC	; 3 42
    411  f955							;---------------------------------------
    412  f955							; start of line 2 of the 2LK
    413  f955		       85 1b		      sta	GRP0	; 3  3 - @0-22, update player0 graphics
    414  f957		       88		      dey		; 2  5 - decrease the 2LK loop counter
    415  f958		       d0 ca		      bne	ArenaLoop	; 2  7 - (3  8) branch if there's more Arena to draw
    416  f95a		       84 0d		      sty	PF0	; 3 10 - Y is 0, blank out playfield
    417  f95c		       84 0e		      sty	PF1	; 3 13 - Y is 0, blank out playfield
    418  f95e		       84 0f		      sty	PF2	; 3 16 - Y is 0, blank out playfield
    419  f960		       60		      rts		; 6 22 - ReTurn from Subroutine
    420  f961
    421  f961
    422  f961							;===============================================================================
    423  f961							; Overscan
    424  f961							; --------------
    425  f961							; Process Object Collisions here
    426  f961							;===============================================================================
    427  f961
    428  f961				   OverScan
    429  f961		       85 02		      sta	WSYNC	; Wait for SYNC (halts CPU until end of scanline)
    430  f963		       a9 02		      lda	#2	; LoaD Accumulator with 2 so D1=1
    431  f965		       85 01		      sta	VBLANK	; STore Accumulator to VBLANK, D1=1 turns image output off
    432  f967
    433  f967							; set the Score+1 for 27 scanlines.  Each scanline lasts 76 cycles,
    434  f967							; but the Score+1 counts down once every 64 cycles, so use this
    435  f967							; formula to figure out the value to set.
    436  f967							;	 (scanlines * 76) / 64
    437  f967							; Also note that it might be slight off due to when on the scanline TIM64T
    438  f967							; is updated.	So use Stella to check how many scanlines the code is
    439  f967							; generating and adjust accordingly.
    440  f967							;
    441  f967							; originally 32, changed to 35 after tweaking size of Arena
    442  f967		       a9 23		      lda	#35	; set Score+1 for 27 scanlines, 32 = ((27 * 76) / 64)
    443  f969		       8d 96 02 	      sta	TIM64T	; set Score+1 to go off in 27 scanlines
    444  f96c
    445  f96c							; Test if player collided with playfield
    446  f96c		       24 02		      bit	CXP0FB	; N = player0/playfield, V=player0/ball
    447  f96e		       10 08		      bpl	notP0PF	; if N is off, then player0 did not collide with playfield
    448  f970		       a5 a1		      lda	SavedX	; recall saved X
    449  f972		       85 89		      sta	ObjectX	; and move player back to it
    450  f974		       a5 a3		      lda	SavedY	; recall saved Y
    451  f976		       85 8e		      sta	ObjectY	; and move player back to it
    452  f978				   notP0PF
    453  f978		       24 03		      bit	CXP1FB	; N = player1/playfield, V=player1/ball
    454  f97a		       10 08		      bpl	notP1PF	; if N is off, then player1 did not collide with playfield
    455  f97c		       a5 a2		      lda	SavedX+1	; recall saved X
    456  f97e		       85 8a		      sta	ObjectX+1	; and move player back to it
    457  f980		       a5 a4		      lda	SavedY+1	; recall saved Y
    458  f982		       85 8f		      sta	ObjectY+1	; and move player back to it
    459  f984				   notP1PF
    460  f984
    461  f984				   OSwait
    462  f984		       85 02		      sta	WSYNC	; Wait for SYNC (halts CPU until end of scanline)
    463  f986		       ad 84 02 	      lda	INTIM	; Check the Score+1
    464  f989		       d0 f9		      bne	OSwait	; Branch if its Not Equal to 0
    465  f98b		       60		      rts		; ReTurn from Subroutine
    466  f98c
    467  f98c
    468  f98c							;===============================================================================
    469  f98c							; UpdateTimer
    470  f98c							; -----------
    471  f98c							; udpates timer display
    472  f98c							;===============================================================================
    473  f98c				   UpdateTimer
    474  f98c		       a5 99		      lda	Frame
    475  f98e		       29 3f		      and	#63
    476  f990		       f0 01		      beq	TimerTick
    477  f992		       60		      rts
    478  f993
    479  f993				   TimerTick
    480  f993		       a5 9a		      lda	TimerPF
    481  f995		       29 f0		      and	#%11110000
    482  f997		       d0 0f		      bne	DecrementTimer
    483  f999							; reset timer for demo
    484  f999		       a9 ff		      lda	#%11111111
    485  f99b		       85 9a		      sta	TimerPF
    486  f99d		       85 9b		      sta	TimerPF+1
    487  f99f		       85 9c		      sta	TimerPF+2
    488  f9a1		       85 9d		      sta	TimerPF+3
    489  f9a3		       85 9e		      sta	TimerPF+4
    490  f9a5		       85 9f		      sta	TimerPF+5
    491  f9a7		       60		      rts
    492  f9a8
    493  f9a8				   DecrementTimer
    494  f9a8		       46 9f		      lsr	TimerPF+5	; PF2 right side, reversed bits so shift right
    495  f9aa		       26 9e		      rol	TimerPF+4	; PF1 right side, normal bits so shift left
    496  f9ac		       66 9d		      ror	TimerPF+3	; PF0 right side, reversed bits so shift right
    497  f9ae		       a5 9d		      lda	TimerPF+3	; only upper nybble used, so we need to put bit 3 into C
    498  f9b0		       4a		      lsr
    499  f9b1		       4a		      lsr
    500  f9b2		       4a		      lsr
    501  f9b3		       4a		      lsr
    502  f9b4		       66 9c		      ror	TimerPF+2	; PF2 left side, reversed bits so shift right
    503  f9b6		       26 9b		      rol	TimerPF+1	; PF1 left side, normal bits so shift left
    504  f9b8		       66 9a		      ror	TimerPF	; PF0 left side, reversed bits so shift right
    505  f9ba		       60		      rts
    506  f9bb
    507  f9bb							;===============================================================================
    508  f9bb							; ProcessJoystick
    509  f9bb							; --------------
    510  f9bb							; Read left joystick and move the humanoid
    511  f9bb							; for testing, read right joystick and move second humanoid
    512  f9bb							;
    513  f9bb							; joystick directions are held in the SWCHA register of the RIOT chip.
    514  f9bb							; Directions are read via the following bit pattern:
    515  f9bb							;   76543210
    516  f9bb							;   RLDUrldu
    517  f9bb							;
    518  f9bb							; UPPERCASE denotes the left joystick directions
    519  f9bb							; lowercase denotes the right joystick directions
    520  f9bb							;
    521  f9bb							; NOTE the values are the opposite of what you might expect. If the direction
    522  f9bb							; is held, the bit value will be 0.
    523  f9bb							;
    524  f9bb							; Fire buttons are read via INPT4 (left) and INPT5 (right).  They are currently
    525  f9bb							; used to slow down player movement to make alignment testing easier.
    526  f9bb							;===============================================================================
    527  f9bb				   ProcessJoystick
    528  f9bb		       ad 80 02 	      lda	SWCHA	; reads joystick positions
    529  f9be
    530  f9be		       a2 00		      ldx	#0	; x=0 for left joystick, x=1 for right
    531  f9c0				   PJloop
    532  f9c0		       b4 89		      ldy	ObjectX,x	; save original Y location so the player can be
    533  f9c2		       94 a1		      sty	SavedX,x	;   bounced back upon colliding with the playfield
    534  f9c4		       b4 8e		      ldy	ObjectY,x	; save original Y location so the player can be
    535  f9c6		       94 a3		      sty	SavedY,x	;   bounced back upon colliding with the playfield
    536  f9c8		       b4 0c		      ldy	INPT4,x	; check the firebutton for this joystick
    537  f9ca		       30 10		      bmi	NormalSpeed	; if it's not held down then player moves at full speed
    538  f9cc		       48		      pha		; PusH A onto stack (saves value of A)
    539  f9cd		       a5 99		      lda	Frame	; if it is held down, then only move once every 8 frames
    540  f9cf		       29 07		      and	#7
    541  f9d1		       f0 08		      beq	SlowMovement
    542  f9d3		       68		      pla		; PuLl A from stack (restores value of A)
    543  f9d4		       0a		      asl		; shift the 4 direction readings out of A
    544  f9d5		       0a		      asl		; so the other joystick can be processed
    545  f9d6		       0a		      asl
    546  f9d7		       0a		      asl
    547  f9d8		       4c 1c fa 	      jmp	NextJoystick
    548  f9db
    549  f9db				   SlowMovement
    550  f9db		       68		      pla		; PuLl A from stack (restores value of A)
    551  f9dc				   NormalSpeed
    552  f9dc		       0a		      asl		; shift A bits left, R is now in the carry bit
    553  f9dd		       b0 0f		      bcs	CheckLeft	; branch if joystick is not held right
    554  f9df		       b4 89		      ldy	ObjectX,x	; get the object's X position
    555  f9e1		       c8		      iny		; and move it right
    556  f9e2		       c0 a0		      cpy	#160	; test for edge of screen
    557  f9e4		       d0 02		      bne	SaveX	; save Y if we're not at the edge
    558  f9e6		       a0 00		      ldy	#0	; else wrap to left edge
    559  f9e8		       94 89	   SaveX      sty	ObjectX,x	; saveX
    560  f9ea		       a0 00		      ldy	#0	; turn off reflect of player, which
    561  f9ec		       94 0b		      sty	REFP0,x	; makes humanoid image face right
    562  f9ee
    563  f9ee				   CheckLeft
    564  f9ee		       0a		      asl		; shift A bits left, L is now in the carry bit
    565  f9ef		       b0 0f		      bcs	CheckDown	; branch if joystick not held left
    566  f9f1		       b4 89		      ldy	ObjectX,x	; get the object's X position
    567  f9f3		       88		      dey		; and move it left
    568  f9f4		       c0 ff		      cpy	#255	; test for edge of screen
    569  f9f6		       d0 02		      bne	SaveX2	; save X if we're not at the edge
    570  f9f8		       a0 9f		      ldy	#159	; else wrap to right edge
    571  f9fa		       94 89	   SaveX2     sty	ObjectX,x	; save X
    572  f9fc		       a0 08		      ldy	#8	; turn on reflect of player, which
    573  f9fe		       94 0b		      sty	REFP0,x	; makes humanoid image face left
    574  fa00
    575  fa00				   CheckDown
    576  fa00		       0a		      asl		; shift A bits left, D is now in the carry bit
    577  fa01		       b0 0b		      bcs	CheckUp	; branch if joystick not held down
    578  fa03		       b4 8e		      ldy	ObjectY,x	; get the object's Y position
    579  fa05		       88		      dey		; move it down
    580  fa06		       c0 ff		      cpy	#255	; test for bottom of screen
    581  fa08		       d0 02		      bne	SaveY	; save Y if we're not at the bottom
    582  fa0a		       a0 af		      ldy	#ARENA_HEIGHT*2+1	; else wrap to top
    583  fa0c		       94 8e	   SaveY      sty	ObjectY,x	; save Y
    584  fa0e
    585  fa0e				   CheckUp
    586  fa0e		       0a		      asl		; shift A bits left, U is now in the carry bit
    587  fa0f		       b0 0b		      bcs	NextJoystick	; branch if joystick not held up
    588  fa11		       b4 8e		      ldy	ObjectY,x	; get the object's Y position
    589  fa13		       c8		      iny		; move it up
    590  fa14		       c0 b0		      cpy	#ARENA_HEIGHT*2+2	; test for top of screen
    591  fa16		       d0 02		      bne	SaveY2	; save Y if we're not at the top
    592  fa18		       a0 00		      ldy	#0	; else wrap to bottom
    593  fa1a		       94 8e	   SaveY2     sty	ObjectY,x	; save Y
    594  fa1c
    595  fa1c				   NextJoystick
    596  fa1c		       e8		      inx		; increase loop control
    597  fa1d		       e0 02		      cpx	#2	; check if we've processed both joysticks
    598  fa1f		       d0 9f		      bne	PJloop	; branch if we haven't
    599  fa21
    600  fa21		       60		      rts
    601  fa22
    602  fa22							;===============================================================================
    603  fa22							; PositionObjects
    604  fa22							; --------------
    605  fa22							; Updates TIA for X position of all objects
    606  fa22							; Updates Kernel variables for Y position of all objects
    607  fa22							;===============================================================================
    608  fa22				   PositionObjects
    609  fa22		       a2 01		      ldx	#1	; position objects 0-1: player0 and player1
    610  fa24				   POloop
    611  fa24		       b5 89		      lda	ObjectX,x	; get the object's X position
    612  fa26		       20 00 f8 	      jsr	PosObject	; set coarse X position and fine-tune amount
    613  fa29		       ca		      dex		; DEcrement X
    614  fa2a		       10 f8		      bpl	POloop	; Branch PLus so we position all objects
    615  fa2c		       85 02		      sta	WSYNC	; wait for end of scanline
    616  fa2e		       85 2a		      sta	HMOVE	; use fine-tune values to set final X positions
    617  fa30
    618  fa30							; prep player 1's Y position for 2LK
    619  fa30		       a2 01		      ldx	#1	; preload X for setting VDELPx
    620  fa32		       a5 8e		      lda	ObjectY	; get the human's Y position
    621  fa34		       18		      clc
    622  fa35		       69 01		      adc	#1	; add 1 to compensate for priming of GRP0
    623  fa37		       4a		      lsr		; divide by 2 for the 2LK position
    624  fa38		       85 88		      sta	Temp	; save for position calculations
    625  fa3a		       b0 02		      bcs	NoDelay0	; if carry is set we don't need Vertical Delay
    626  fa3c		       86 25		      stx	VDELP0	; carry was clear, so set Vertical Delay
    627  fa3e				   NoDelay0
    628  fa3e							; Player0Draw = ARENA_HEIGHT + HUMAN_HEIGHT - Y position + 1
    629  fa3e							; the + 1 compensates for priming of GRP0
    630  fa3e		       a9 62		      lda	#(ARENA_HEIGHT + HUMAN_HEIGHT + 1)
    631  fa40		       38		      sec
    632  fa41		       e5 88		      sbc	Temp
    633  fa43		       85 93		      sta	Player0Draw
    634  fa45
    635  fa45							; Player0Ptr = HumanGfx + HUMAN_HEIGHT - 1 - Y position
    636  fa45		       a9 59		      lda	#<(HumanGfx + HUMAN_HEIGHT - 1)
    637  fa47		       38		      sec
    638  fa48		       e5 88		      sbc	Temp
    639  fa4a		       85 95		      sta	Player0Ptr
    640  fa4c		       a9 fb		      lda	#>(HumanGfx + HUMAN_HEIGHT - 1)
    641  fa4e		       e9 00		      sbc	#0
    642  fa50		       85 96		      sta	Player0Ptr+1
    643  fa52
    644  fa52							; prep player 2's Y position for 2LK
    645  fa52		       a5 8f		      lda	ObjectY+1	; get the box's Y position
    646  fa54		       4a		      lsr		; divide by 2 for the 2LK position
    647  fa55		       85 88		      sta	Temp	; save for position calculations
    648  fa57		       b0 02		      bcs	NoDelay1	; if carry is set we don't need Vertical Delay
    649  fa59		       86 26		      stx	VDELP1	; carry was clear, so set Vertical Delay
    650  fa5b				   NoDelay1
    651  fa5b							; Player1Draw = ARENA_HEIGHT + HUMAN_HEIGHT - Y position + 1
    652  fa5b		       a9 61		      lda	#(ARENA_HEIGHT + HUMAN_HEIGHT)
    653  fa5d		       38		      sec
    654  fa5e		       e5 88		      sbc	Temp
    655  fa60		       85 94		      sta	Player1Draw
    656  fa62
    657  fa62		       a2 00		      ldx	#0
    658  fa64		       2c 82 02 	      bit	SWCHB
    659  fa67		       10 02		      bpl	TwoPlayer
    660  fa69		       a2 01		      ldx	#1
    661  fa6b				   TwoPlayer
    662  fa6b							; Player1Ptr = BoxGfx + HUMAN_HEIGHT - 1 - Y position
    663  fa6b		       bd 7b fa 	      lda	ShapePtrLow,x
    664  fa6e		       38		      sec
    665  fa6f		       e5 88		      sbc	Temp
    666  fa71		       85 97		      sta	Player1Ptr
    667  fa73		       bd 7d fa 	      lda	ShapePtrHi,x
    668  fa76		       e9 00		      sbc	#0
    669  fa78		       85 98		      sta	Player1Ptr+1
    670  fa7a
    671  fa7a		       60		      rts
    672  fa7b
    673  fa7b				   ShapePtrLow
    674  fa7b		       59		      .byte.b	<(HumanGfx + HUMAN_HEIGHT - 1)
    675  fa7c		       63		      .byte.b	<(BoxGfx + HUMAN_HEIGHT - 1)
    676  fa7d
    677  fa7d				   ShapePtrHi
    678  fa7d		       fb		      .byte.b	>(HumanGfx + HUMAN_HEIGHT - 1)
    679  fa7e		       fb		      .byte.b	>(BoxGfx + HUMAN_HEIGHT - 1)
    680  fa7f
    681  fa7f							;===============================================================================
    682  fa7f							; SetObjectColors
    683  fa7f							; --------------
    684  fa7f							; Set the 4 color registers based on the state of TV Type.
    685  fa7f							; Eventually this will also handle color cycling of attract mode
    686  fa7f							;===============================================================================
    687  fa7f				   SetObjectColors
    688  fa7f		       a2 04		      ldx	#4	; we're going to set 5 colors (0-4)
    689  fa81		       a0 04		      ldy	#4	; default to the color entries in the table (0-4)
    690  fa83		       ad 82 02 	      lda	SWCHB	; read the state of the console switches
    691  fa86		       29 08		      and	#%00001000	; test state of D3, the TV Type switch
    692  fa88		       d0 02		      bne	SOCloop	; if D3=1 then use color
    693  fa8a		       a0 09		      ldy	#9	; else use the b&w entries in the table (5-9)
    694  fa8c				   SOCloop
    695  fa8c		       b9 9b fa 	      lda	Colors,y	; get the color or b&w value
    696  fa8f		       95 05		      sta	COLUP0-1,x	; and set it
    697  fa91		       88		      dey		; decrease Y
    698  fa92		       ca		      dex		; decrease X
    699  fa93		       d0 f7		      bne	SOCloop	; Branch Not Equal to Zero
    700  fa95		       b9 9b fa 	      lda	Colors,y	; get the Arena color
    701  fa98		       85 a0		      sta	ArenaColor	; save in RAM for Kernal Usage
    702  fa9a
    703  fa9a		       60		      rts		; ReTurn from Subroutine
    704  fa9b
    705  fa9b				   Colors
    706  fa9b		       46		      .byte.b	$46	; red	      - goes into COLUPF, color for Arena (after Timer is drawn)
    707  fa9c		       86		      .byte.b	$86	; blue       - goes into COLUP0, color for player0 and missile0
    708  fa9d		       c6		      .byte.b	$C6	; green      - goes into COLUP1, color for player1 and missile1
    709  fa9e		       64		      .byte.b	$64	; purple     - goes into COLUPF, color for Timer
    710  fa9f		       00		      .byte.b	$00	; black      - goes into COLUBK, color for background
    711  faa0		       0a		      .byte.b	$0A	; light grey - goes into COLUPF, color for Arena (after Timer is drawn)
    712  faa1		       0e		      .byte.b	$0E	; white      - goes into COLUP0, color for player0 and missile0
    713  faa2		       06		      .byte.b	$06	; dark grey  - goes into COLUP1, color for player1 and missile1
    714  faa3		       04		      .byte.b	$04	; dark grey  - goes into COLUPF, color for Timer
    715  faa4		       00		      .byte.b	$00	; black      - goes into COLUBK, color for background
    716  faa5
    717  faa5							;===============================================================================
    718  faa5							; PrepScoreForDisplay
    719  faa5							; --------------
    720  faa5							; Converts the high and low nybbles of the RAM variables Score and Score+1
    721  faa5							; into offsets into the digit graphics so the values can be displayed.
    722  faa5							; Each digit uses 5 bytes of data for the graphics.  For the low nybble we need
    723  faa5							; to multiply by 5, but the 6507 does not have a multiply feature.  It can,
    724  faa5							; however, shift the bits in a byte left, which is the same as a multiply by 2.
    725  faa5							; Using this, we can get multiply a # by 5 like this:
    726  faa5							;	 # * 5 = (# * 2 * 2) + #
    727  faa5							; The value in the upper nybble is already times 16, so we need to divide it.
    728  faa5							; The 6507 can shift the bits the right, which is the same as divide by 2.
    729  faa5							;	 (# / 16) * 5 = (# / 2 / 2) + (# / 2 / 2 / 2 / 2)
    730  faa5							;===============================================================================
    731  faa5
    732  faa5				   PrepScoreForDisplay
    733  faa5							; for testing purposes, set Score to Humanoid Y and Score+1 to Box Y
    734  faa5		       a5 8e		      lda	ObjectY
    735  faa7		       85 80		      sta	Score
    736  faa9		       a5 8f		      lda	ObjectY+1
    737  faab		       85 81		      sta	Score+1
    738  faad
    739  faad				   PSFDskip
    740  faad		       a2 01		      ldx	#1	; use X as the loop counter for PSFDloop
    741  faaf				   PSFDloop
    742  faaf		       b5 80		      lda	Score,x	; LoaD A with Score+1(first pass) or Score(second pass)
    743  fab1		       29 0f		      and	#$0F	; remove the tens digit
    744  fab3		       85 88		      sta	Temp	; Store A into Temp
    745  fab5		       0a		      asl		; Accumulator Shift Left (# * 2)
    746  fab6		       0a		      asl		; Accumulator Shift Left (# * 4)
    747  fab7		       65 88		      adc	Temp	; ADd with Carry value in Temp (# * 5)
    748  fab9		       95 82		      sta	DigitOnes,x	; STore A in DigitOnes+1(first pass) or DigitOnes(second pass)
    749  fabb		       b5 80		      lda	Score,x	; LoaD A with Score+1(first pass) or Score(second pass)
    750  fabd		       29 f0		      and	#$F0	; remove the ones digit
    751  fabf		       4a		      lsr		; Logical Shift Right (# / 2)
    752  fac0		       4a		      lsr		; Logical Shift Right (# / 4)
    753  fac1		       85 88		      sta	Temp	; Store A into Temp
    754  fac3		       4a		      lsr		; Logical Shift Right (# / 8)
    755  fac4		       4a		      lsr		; Logical Shift Right (# / 16)
    756  fac5		       65 88		      adc	Temp	; ADd with Carry value in Temp ((# / 16) * 5)
    757  fac7		       95 84		      sta	DigitTens,x	; STore A in DigitTens+1(first pass) or DigitTens(second pass)
    758  fac9		       ca		      dex		; DEcrement X by 1
    759  faca		       10 e3		      bpl	PSFDloop	; Branch PLus (positive) to PSFDloop
    760  facc		       60		      rts		; ReTurn from Subroutine
    761  facd
    762  facd
    763  facd							;===============================================================================
    764  facd							; free space check before DigitGfx
    765  facd							;===============================================================================
    766  facd
    767  facd					      if	(* & $FF)
 ------ 51 bytes free before DigitGfx
    768  facd					      echo	"------", [(>.+1)*256 - .]d, "bytes free before DigitGfx"
    769  fb00		       00 00 00 00*	      align	256
    770  fb00					      endif
    771  fb00
    772  fb00
    773  fb00							;===============================================================================
    774  fb00							; Digit Graphics
    775  fb00							;===============================================================================
    776  fb00					      align	256
    777  fb00				   DigitGfx
    778  fb00		       77		      .byte.b	%01110111
    779  fb01		       55		      .byte.b	%01010101
    780  fb02		       55		      .byte.b	%01010101
    781  fb03		       55		      .byte.b	%01010101
    782  fb04		       77		      .byte.b	%01110111
    783  fb05
    784  fb05		       11		      .byte.b	%00010001
    785  fb06		       11		      .byte.b	%00010001
    786  fb07		       11		      .byte.b	%00010001
    787  fb08		       11		      .byte.b	%00010001
    788  fb09		       11		      .byte.b	%00010001
    789  fb0a
    790  fb0a		       77		      .byte.b	%01110111
    791  fb0b		       11		      .byte.b	%00010001
    792  fb0c		       77		      .byte.b	%01110111
    793  fb0d		       44		      .byte.b	%01000100
    794  fb0e		       77		      .byte.b	%01110111
    795  fb0f
    796  fb0f		       77		      .byte.b	%01110111
    797  fb10		       11		      .byte.b	%00010001
    798  fb11		       33		      .byte.b	%00110011
    799  fb12		       11		      .byte.b	%00010001
    800  fb13		       77		      .byte.b	%01110111
    801  fb14
    802  fb14		       55		      .byte.b	%01010101
    803  fb15		       55		      .byte.b	%01010101
    804  fb16		       77		      .byte.b	%01110111
    805  fb17		       11		      .byte.b	%00010001
    806  fb18		       11		      .byte.b	%00010001
    807  fb19
    808  fb19		       77		      .byte.b	%01110111
    809  fb1a		       44		      .byte.b	%01000100
    810  fb1b		       77		      .byte.b	%01110111
    811  fb1c		       11		      .byte.b	%00010001
    812  fb1d		       77		      .byte.b	%01110111
    813  fb1e
    814  fb1e		       77		      .byte.b	%01110111
    815  fb1f		       44		      .byte.b	%01000100
    816  fb20		       77		      .byte.b	%01110111
    817  fb21		       55		      .byte.b	%01010101
    818  fb22		       77		      .byte.b	%01110111
    819  fb23
    820  fb23		       77		      .byte.b	%01110111
    821  fb24		       11		      .byte.b	%00010001
    822  fb25		       11		      .byte.b	%00010001
    823  fb26		       11		      .byte.b	%00010001
    824  fb27		       11		      .byte.b	%00010001
    825  fb28
    826  fb28		       77		      .byte.b	%01110111
    827  fb29		       55		      .byte.b	%01010101
    828  fb2a		       77		      .byte.b	%01110111
    829  fb2b		       55		      .byte.b	%01010101
    830  fb2c		       77		      .byte.b	%01110111
    831  fb2d
    832  fb2d		       77		      .byte.b	%01110111
    833  fb2e		       55		      .byte.b	%01010101
    834  fb2f		       77		      .byte.b	%01110111
    835  fb30		       11		      .byte.b	%00010001
    836  fb31		       77		      .byte.b	%01110111
    837  fb32
    838  fb32		       22		      .byte.b	%00100010
    839  fb33		       55		      .byte.b	%01010101
    840  fb34		       77		      .byte.b	%01110111
    841  fb35		       55		      .byte.b	%01010101
    842  fb36		       55		      .byte.b	%01010101
    843  fb37
    844  fb37		       66		      .byte.b	%01100110
    845  fb38		       55		      .byte.b	%01010101
    846  fb39		       66		      .byte.b	%01100110
    847  fb3a		       55		      .byte.b	%01010101
    848  fb3b		       66		      .byte.b	%01100110
    849  fb3c
    850  fb3c		       33		      .byte.b	%00110011
    851  fb3d		       44		      .byte.b	%01000100
    852  fb3e		       44		      .byte.b	%01000100
    853  fb3f		       44		      .byte.b	%01000100
    854  fb40		       33		      .byte.b	%00110011
    855  fb41
    856  fb41		       66		      .byte.b	%01100110
    857  fb42		       55		      .byte.b	%01010101
    858  fb43		       55		      .byte.b	%01010101
    859  fb44		       55		      .byte.b	%01010101
    860  fb45		       66		      .byte.b	%01100110
    861  fb46
    862  fb46		       77		      .byte.b	%01110111
    863  fb47		       44		      .byte.b	%01000100
    864  fb48		       66		      .byte.b	%01100110
    865  fb49		       44		      .byte.b	%01000100
    866  fb4a		       77		      .byte.b	%01110111
    867  fb4b
    868  fb4b		       77		      .byte.b	%01110111
    869  fb4c		       44		      .byte.b	%01000100
    870  fb4d		       66		      .byte.b	%01100110
    871  fb4e		       44		      .byte.b	%01000100
    872  fb4f		       44		      .byte.b	%01000100
    873  fb50
    874  fb50				   HumanGfx
    875  fb50		       1c		      .byte.b	%00011100
    876  fb51		       18		      .byte.b	%00011000
    877  fb52		       18		      .byte.b	%00011000
    878  fb53		       18		      .byte.b	%00011000
    879  fb54		       5a		      .byte.b	%01011010
    880  fb55		       5a		      .byte.b	%01011010
    881  fb56		       3c		      .byte.b	%00111100
    882  fb57		       00		      .byte.b	%00000000
    883  fb58		       18		      .byte.b	%00011000
    884  fb59		       18		      .byte.b	%00011000
    885  fb59		       00 0a	   HUMAN_HEIGHT =	* - HumanGfx
    886  fb5a
    887  fb5a				   BoxGfx
    888  fb5a		       00		      .byte.b	%00000000
    889  fb5b		       00		      .byte.b	%00000000
    890  fb5c		       ff		      .byte.b	%11111111
    891  fb5d		       81		      .byte.b	%10000001
    892  fb5e		       81		      .byte.b	%10000001
    893  fb5f		       81		      .byte.b	%10000001
    894  fb60		       81		      .byte.b	%10000001
    895  fb61		       81		      .byte.b	%10000001
    896  fb62		       81		      .byte.b	%10000001
    897  fb63		       ff		      .byte.b	%11111111
    898  fb64
    899  fb64				   ArenaPF0		; PF0 is drawn in reverse order, and only the upper nybble
    900  fb64		       f0		      .byte.b	%11110000
    901  fb65		       10		      .byte.b	%00010000
    902  fb66		       10		      .byte.b	%00010000
    903  fb67		       10		      .byte.b	%00010000
    904  fb68		       10		      .byte.b	%00010000
    905  fb69		       10		      .byte.b	%00010000
    906  fb6a		       10		      .byte.b	%00010000
    907  fb6b		       10		      .byte.b	%00010000
    908  fb6c		       10		      .byte.b	%00010000
    909  fb6d		       10		      .byte.b	%00010000
    910  fb6e		       10		      .byte.b	%00010000
    911  fb6f		       10		      .byte.b	%00010000
    912  fb70		       10		      .byte.b	%00010000
    913  fb71		       10		      .byte.b	%00010000
    914  fb72		       10		      .byte.b	%00010000
    915  fb73		       10		      .byte.b	%00010000
    916  fb74		       10		      .byte.b	%00010000
    917  fb75		       10		      .byte.b	%00010000
    918  fb76		       10		      .byte.b	%00010000
    919  fb77		       10		      .byte.b	%00010000
    920  fb78		       10		      .byte.b	%00010000
    921  fb79		       f0		      .byte.b	%11110000
    922  fb7a
    923  fb7a				   ArenaPF1		; PF1 is drawn in expected order
    924  fb7a		       ff		      .byte.b	%11111111
    925  fb7b		       00		      .byte.b	%00000000
    926  fb7c		       00		      .byte.b	%00000000
    927  fb7d		       38		      .byte.b	%00111000
    928  fb7e		       00		      .byte.b	%00000000
    929  fb7f		       00		      .byte.b	%00000000
    930  fb80		       00		      .byte.b	%00000000
    931  fb81		       c0		      .byte.b	%11000000
    932  fb82		       40		      .byte.b	%01000000
    933  fb83		       40		      .byte.b	%01000000
    934  fb84		       41		      .byte.b	%01000001
    935  fb85		       41		      .byte.b	%01000001
    936  fb86		       40		      .byte.b	%01000000
    937  fb87		       40		      .byte.b	%01000000
    938  fb88		       c0		      .byte.b	%11000000
    939  fb89		       00		      .byte.b	%00000000
    940  fb8a		       00		      .byte.b	%00000000
    941  fb8b		       00		      .byte.b	%00000000
    942  fb8c		       38		      .byte.b	%00111000
    943  fb8d		       00		      .byte.b	%00000000
    944  fb8e		       00		      .byte.b	%00000000
    945  fb8f		       ff		      .byte.b	%11111111
    946  fb90
    947  fb90				   ArenaPF2		; PF2 is drawn in reverse order
    948  fb90		       ff		      .byte.b	%11111111
    949  fb91		       80		      .byte.b	%10000000
    950  fb92		       00		      .byte.b	%00000000
    951  fb93		       00		      .byte.b	%00000000
    952  fb94		       00		      .byte.b	%00000000
    953  fb95		       00		      .byte.b	%00000000
    954  fb96		       1c		      .byte.b	%00011100
    955  fb97		       04		      .byte.b	%00000100
    956  fb98		       00		      .byte.b	%00000000
    957  fb99		       00		      .byte.b	%00000000
    958  fb9a		       00		      .byte.b	%00000000
    959  fb9b		       00		      .byte.b	%00000000
    960  fb9c		       00		      .byte.b	%00000000
    961  fb9d		       00		      .byte.b	%00000000
    962  fb9e		       04		      .byte.b	%00000100
    963  fb9f		       1c		      .byte.b	%00011100
    964  fba0		       00		      .byte.b	%00000000
    965  fba1		       00		      .byte.b	%00000000
    966  fba2		       00		      .byte.b	%00000000
    967  fba3		       00		      .byte.b	%00000000
    968  fba4		       80		      .byte.b	%10000000
    969  fba5		       ff		      .byte.b	%11111111
    970  fba6
    971  fba6
    972  fba6							;===============================================================================
    973  fba6							; free space check before End of Cartridge
    974  fba6							;===============================================================================
    975  fba6
    976  fba6					      if	(* & $FF)
 ------ 1108 bytes free before End of Cartridge
    977  fba6					      echo	"------", [$FFFA - *]d, "bytes free before End of Cartridge"
    978  fc00		       00 00 00 00*	      align	256
    979  fc00					      endif
    980  fc00
    981  fc00							;===============================================================================
    982  fc00							; Define End of Cartridge
    983  fc00							;===============================================================================
    984  fffa					      ORG	$FFFA	; set address to 6507 Interrupt Vectors
    985  fffa		       13 f8		      .WORD.w	InitSystem	; NMI
    986  fffc		       13 f8		      .WORD.w	InitSystem	; RESET
    987  fffe		       13 f8		      .WORD.w	InitSystem	; IRQ
