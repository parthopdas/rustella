------- FILE D:\src\u\s\emu\tests\bins\8blit\8blit-s04e01-Purrballs.asm LEVEL 1 PASS 2
      1  10000 ????						; S04E01 Purrballs
      2  10000 ????
      3  10000 ????						; Implementing a scoreboard in a game context
      4  10000 ????
      5  10000 ????						; This Episode on Youtube - https://www.youtube.com/watch?v=lUJmDX1fd18
      6  10000 ????
      7  10000 ????						; Become a Patron - https://patreon.com/8blit
      8  10000 ????						; 8blit Merch - https://8blit.myspreadshop.com/
      9  10000 ????						; Subscribe to 8Blit - https://www.youtube.com/8blit?sub_confirmation=1
     10  10000 ????						; Follow on Facebook - https://www.facebook.com/8Blit
     11  10000 ????						; Follow on Instagram - https://www.instagram.com/8blit
     12  10000 ????						; Visit the Website - https://www.8blit.com 
     13  10000 ????
     14  10000 ????						; Email - 8blit0@gmail.com
     15  10000 ????
     16  10000 ????				       processor	6502
     17  10000 ????
------- FILE vcs.h LEVEL 2 PASS 2
      0  10000 ????				       include	"vcs.h"
      1  10000 ????						; VCS.H
      2  10000 ????						; Version 1.06, 06/SEP/2020
      3  10000 ????
      4  10000 ????		00 6a	    VERSION_VCS =	106
      5  10000 ????
      6  10000 ????						; THIS IS *THE* "STANDARD" VCS.H
      7  10000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8  10000 ????						; The latest version can be found at https://dasm-assembler.github.io/
      9  10000 ????						;
     10  10000 ????						; This file defines hardware registers and memory mapping for the
     11  10000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     12  10000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     13  10000 ????						; available at at https://dasm-assembler.github.io/
     14  10000 ????						;
     15  10000 ????						; Many thanks to the people who have contributed. If you find an issue with the
     16  10000 ????						; contents, or would like ot add something, please report as an issue at...
     17  10000 ????						; https://github.com/dasm-assembler/dasm/issues
     18  10000 ????
     19  10000 ????						;
     20  10000 ????						; Latest Revisions...
     21  10000 ????						; 1.06  05/SEP/2020	 Modified header/license and links to new versions
     22  10000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     23  10000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     24  10000 ????						;			    This will allow conditional code to verify VCS.H being
     25  10000 ????						;			    used for code assembly.
     26  10000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     27  10000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     28  10000 ????						;			 mirrored reading/writing differences.	This is more a 
     29  10000 ????						;			 readability issue, and binary compatibility with disassembled
     30  10000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     31  10000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     32  10000 ????						;			 which was broken by the use of segments in this file, as
     33  10000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     34  10000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     35  10000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     36  10000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     37  10000 ????						;						   it is safe to leave it undefined, and the base address will
     38  10000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     39  10000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     40  10000 ????						;			  - register definitions are now generated through assignment
     41  10000 ????						;			    in uninitialised segments.	This allows a changeable base
     42  10000 ????						;			    address architecture.
     43  10000 ????						; 1.0	22/MAR/2003		Initial release
     44  10000 ????
     45  10000 ????
     46  10000 ????						;-------------------------------------------------------------------------------
     47  10000 ????
     48  10000 ????						; TIA_BASE_ADDRESS
     49  10000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     50  10000 ????						; Normally 0, the base address should (externally, before including this file)
     51  10000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     52  10000 ????						; The reason is that this bankswitching scheme treats any access to locations
     53  10000 ????						; < $40 as a bankswitch.
     54  10000 ????
     55  10000 ????			   -	       IFNCONST	TIA_BASE_ADDRESS
     56  10000 ????			   -TIA_BASE_ADDRESS =	0
     57  10000 ????				       ENDIF
     58  10000 ????
     59  10000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     60  10000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     61  10000 ????						; *OR* by declaring the label before including this file, eg:
     62  10000 ????						; TIA_BASE_ADDRESS = $40
     63  10000 ????						;   include "vcs.h"
     64  10000 ????
     65  10000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     66  10000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     67  10000 ????						; for the mirrored ROM hardware registers.
     68  10000 ????
     69  10000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     70  10000 ????						; using the -D command-line switch, as required.  If the addresses are not defined, 
     71  10000 ????						; they defaut to the TIA_BASE_ADDRESS.
     72  10000 ????
     73  10000 ????			   -	       IFNCONST	TIA_BASE_READ_ADDRESS
     74  10000 ????			   -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     75  10000 ????				       ENDIF
     76  10000 ????
     77  10000 ????			   -	       IFNCONST	TIA_BASE_WRITE_ADDRESS
     78  10000 ????			   -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     79  10000 ????				       ENDIF
     80  10000 ????
     81  10000 ????						;-------------------------------------------------------------------------------
     82  10000 ????
     83 U002d ????				      SEG.U	TIA_REGISTERS_WRITE
     84 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     85 U0000
     86 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     87 U0000
     88 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     89 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     90 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     91 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     92 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     93 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     94 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     95 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     96 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     97 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     98 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     99 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    100 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    101 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    102 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    103 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    104 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    105 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    106 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    107 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    108 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    109 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    110 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    111 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    112 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    113 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    114 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    115 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    116 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    117 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    118 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    119 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    120 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    121 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    122 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    123 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    124 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    125 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    126 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    127 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    128 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    129 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    130 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    131 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    132 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    133 U002d
    134 U002d							;-------------------------------------------------------------------------------
    135 U002d
    136 U000e ????				      SEG.U	TIA_REGISTERS_READ
    137 U0000					      ORG	TIA_BASE_READ_ADDRESS
    138 U0000
    139 U0000							;											bit 7	 bit 6
    140 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    141 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    142 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    143 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    144 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    145 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    146 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    147 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    148 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    149 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    150 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    151 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    152 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    153 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    154 U000e
    155 U000e							;-------------------------------------------------------------------------------
    156 U000e
    157 U0298 ????				      SEG.U	RIOT
    158 U0280					      ORG	$280
    159 U0280
    160 U0280							; RIOT MEMORY MAP
    161 U0280
    162 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    163 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    164 U0281
    165 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    166 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    167 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    168 U0284		       00	   INTIM      ds	1	; $284		Timer output
    169 U0285
    170 U0285		       00	   TIMINT     ds	1	; $285
    171 U0286
    172 U0286							; Unused/undefined registers ($285-$294)
    173 U0286
    174 U0286		       00		      ds	1	; $286
    175 U0287		       00		      ds	1	; $287
    176 U0288		       00		      ds	1	; $288
    177 U0289		       00		      ds	1	; $289
    178 U028a		       00		      ds	1	; $28A
    179 U028b		       00		      ds	1	; $28B
    180 U028c		       00		      ds	1	; $28C
    181 U028d		       00		      ds	1	; $28D
    182 U028e		       00		      ds	1	; $28E
    183 U028f		       00		      ds	1	; $28F
    184 U0290		       00		      ds	1	; $290
    185 U0291		       00		      ds	1	; $291
    186 U0292		       00		      ds	1	; $292
    187 U0293		       00		      ds	1	; $293
    188 U0294
    189 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    190 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    191 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    192 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    193 U0298
    194 U0298							;-------------------------------------------------------------------------------
    195 U0298							; The following required for back-compatibility with code which does not use
    196 U0298							; segments.
    197 U0298
    198  0000 ????				      SEG
    199  0000 ????
    200  0000 ????						; EOF
------- FILE D:\src\u\s\emu\tests\bins\8blit\8blit-s04e01-Purrballs.asm
------- FILE macro.h LEVEL 2 PASS 2
      0  0000 ????				      include	"macro.h"
      1  0000 ????						; MACRO.H
      2  0000 ????						; Version 1.09, 05/SEP/2020
      3  0000 ????
      4  0000 ????	       00 6d	   VERSION_MACRO =	109
      5  0000 ????
      6  0000 ????						;
      7  0000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8  0000 ????						; The latest version can be found at https://dasm-assembler.github.io/
      9  0000 ????						;
     10  0000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     11  0000 ????						; It is distributed as a companion machine-specific support package
     12  0000 ????						; for the DASM compiler.
     13  0000 ????						;
     14  0000 ????						; Many thanks to the people who have contributed. If you find an issue with the
     15  0000 ????						; contents, or would like ot add something, please report as an issue at...
     16  0000 ????						; https://github.com/dasm-assembler/dasm/issues
     17  0000 ????
     18  0000 ????
     19  0000 ????						; Latest Revisions...
     20  0000 ????						; 1.09  05/SEP/2020	 - updated license/links
     21  0000 ????
     22  0000 ????						; 1.08  13/JUL/2020	 - added use of LXA to CLEAN_START
     23  0000 ????						; 1.07  19/JAN/2020	 - correction to comment VERTICAL_SYNC
     24  0000 ????						; 1.06  03/SEP/2004	 - nice revision of VERTICAL_SYNC (Edwin Blink)
     25  0000 ????						; 1.05  14/NOV/2003	 - Added VERSION_MACRO equate (which will reflect 100x version #)
     26  0000 ????						;			   This will allow conditional code to verify MACRO.H being
     27  0000 ????						;			   used for code assembly.
     28  0000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     29  0000 ????						;
     30  0000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     31  0000 ????						;
     32  0000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     33  0000 ????						;			   (standardised macro for vertical synch code)
     34  0000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added. 
     35  0000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     36  0000 ????						; 1.0	22/MAR/2003		Initial release
     37  0000 ????
     38  0000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage, 
     39  0000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     40  0000 ????						;   If you do not allow illegal opcode usage, you must include this file 
     41  0000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     42  0000 ????						;   registers and require them to be defined first).
     43  0000 ????
     44  0000 ????						; Available macros...
     45  0000 ????						;   SLEEP n		 - sleep for n cycles
     46  0000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     47  0000 ????						;   CLEAN_START	 - set machine to known state on startup
     48  0000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     49  0000 ????
     50  0000 ????						;-------------------------------------------------------------------------------
     51  0000 ????						; SLEEP duration
     52  0000 ????						; Original author: Thomas Jentzsch
     53  0000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     54  0000 ????						; useful for code where precise timing is required.
     55  0000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     56  0000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     57  0000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     58  0000 ????
     59  0000 ????				      MAC	sleep
     60  0000 ????			   .CYCLES    SET	{1}
     61  0000 ????
     62  0000 ????				      IF	.CYCLES < 2
     63  0000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     64  0000 ????				      ERR
     65  0000 ????				      ENDIF
     66  0000 ????
     67  0000 ????				      IF	.CYCLES & 1
     68  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     69  0000 ????				      nop	0
     70  0000 ????				      ELSE
     71  0000 ????				      bit	VSYNC
     72  0000 ????				      ENDIF
     73  0000 ????			   .CYCLES    SET	.CYCLES - 3
     74  0000 ????				      ENDIF
     75  0000 ????
     76  0000 ????				      REPEAT	.CYCLES / 2
     77  0000 ????				      nop
     78  0000 ????				      REPEND
     79  0000 ????				      ENDM		;usage: SLEEP n (n>1)
     80  0000 ????
     81  0000 ????						;-------------------------------------------------------------------------------
     82  0000 ????						; VERTICAL_SYNC
     83  0000 ????						; revised version by Edwin Blink -- saves bytes!
     84  0000 ????						; Inserts the code required for a proper 3 scanline vertical sync sequence
     85  0000 ????						; Note: Alters the accumulator
     86  0000 ????
     87  0000 ????						; OUT: A = 0
     88  0000 ????
     89  0000 ????				      MAC	vertical_sync
     90  0000 ????				      lda	#%1110	; each '1' bits generate a VSYNC ON line (bits 1..3)
     91  0000 ????			   .VSLP1     sta	WSYNC	; 1st '0' bit resets Vsync, 2nd '0' bit exit loop
     92  0000 ????				      sta	VSYNC
     93  0000 ????				      lsr
     94  0000 ????				      bne	.VSLP1	; branch until VYSNC has been reset
     95  0000 ????				      ENDM
     96  0000 ????
     97  0000 ????						;-------------------------------------------------------------------------------
     98  0000 ????						; CLEAN_START
     99  0000 ????						; Original author: Andrew Davie
    100  0000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
    101  0000 ????						; Sets stack pointer to $FF, and all registers to 0
    102  0000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    103  0000 ????						; Use as very first section of code on boot (ie: at reset)
    104  0000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    105  0000 ????
    106  0000 ????				      MAC	clean_start
    107  0000 ????				      sei
    108  0000 ????				      cld
    109  0000 ????
    110  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
    111  0000 ????				      lxa	#0
    112  0000 ????				      ELSE
    113  0000 ????				      ldx	#0
    114  0000 ????				      txa
    115  0000 ????				      ENDIF
    116  0000 ????				      tay
    117  0000 ????			   .CLEAR_STACK dex
    118  0000 ????				      txs
    119  0000 ????				      pha
    120  0000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    121  0000 ????
    122  0000 ????				      ENDM
    123  0000 ????
    124  0000 ????						;-------------------------------------------------------
    125  0000 ????						; SET_POINTER
    126  0000 ????						; Original author: Manuel Rotschkar
    127  0000 ????						;
    128  0000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    129  0000 ????						;
    130  0000 ????						; Usage: SET_POINTER pointer, address
    131  0000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    132  0000 ????						;
    133  0000 ????						; Note: Alters the accumulator, NZ flags
    134  0000 ????						; IN 1: 2 byte RAM location reserved for pointer
    135  0000 ????						; IN 2: absolute address
    136  0000 ????
    137  0000 ????				      MAC	set_pointer
    138  0000 ????			   .POINTER   SET	{1}
    139  0000 ????			   .ADDRESS   SET	{2}
    140  0000 ????
    141  0000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    142  0000 ????				      STA	.POINTER	; Store in pointer
    143  0000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    144  0000 ????				      STA	.POINTER+1	; Store in pointer+1
    145  0000 ????
    146  0000 ????				      ENDM
    147  0000 ????
    148  0000 ????						;-------------------------------------------------------
    149  0000 ????						; BOUNDARY byte#
    150  0000 ????						; Original author: Denis Debro (borrowed from Bob Smith / Thomas)
    151  0000 ????						;
    152  0000 ????						; Push data to a certain position inside a page and keep count of how
    153  0000 ????						; many free bytes the programmer will have.
    154  0000 ????						;
    155  0000 ????						; eg: BOUNDARY 5    ; position at byte #5 in page
    156  0000 ????
    157  0000 ????			   .FREE_BYTES SET	0
    158  0000 ????				      MAC	boundary
    159  0000 ????				      REPEAT	256
    160  0000 ????				      IF	<. % {1} = 0
    161  0000 ????				      MEXIT
    162  0000 ????				      ELSE
    163  0000 ????			   .FREE_BYTES SET	.FREE_BYTES + 1
    164  0000 ????				      .byte	$00
    165  0000 ????				      ENDIF
    166  0000 ????				      REPEND
    167  0000 ????				      ENDM
    168  0000 ????
    169  0000 ????
    170  0000 ????						; EOF
------- FILE D:\src\u\s\emu\tests\bins\8blit\8blit-s04e01-Purrballs.asm
------- FILE build.h LEVEL 2 PASS 2
      0  0000 ????				      include	"build.h"
      1  0000 ????	       00 25	   VBLANKLINES =	37
      2  0000 ????	       00 58	   VOUTLINES  =	88	; height of our 2lk kernel playfield 192/2
      3  0000 ????	       00 1e	   OVERSCANLINES =	30
      4  0000 ????	       00 0f	   PFSEGHEIGHT =	%00001111	; pf segements are 4 kernel lines in height
      5  0000 ????
      6  0000 ????						; calculate timings
      7  0000 ????	       00 2b	   VBLANKTIME =	(VBLANKLINES * 76) / 64
      8  0000 ????	       00 23	   OVERSCANTIME =	(OVERSCANLINES * 76) / 64
      9  0000 ????
     10  0000 ????	       00 46	   RED	      =	$46
     11  0000 ????	       00 3c	   ORANGE     =	$3c
     12  0000 ????	       00 1e	   YELLOW     =	$1e
     13  0000 ????	       00 a6	   BLUE       =	$a6
     14  0000 ????	       00 0e	   WHITE      =	$0e
     15  0000 ????
------- FILE D:\src\u\s\emu\tests\bins\8blit\8blit-s04e01-Purrballs.asm
     21  0000 ????
     22  0000 ????	       00 05	   PADDLE_POS =	5
     23  0000 ????	       00 0f	   SOUTLINES  =	15
     24  0000 ????	       00 4b	   MISSILE_YPOS =	75
     25  0000 ????	       00 2b	   MISSILE0_XPOS =	43
     26  0000 ????	       00 74	   MISSILE1_XPOS =	116
     27  0000 ????	       00 1e	   SHOWEARS_LEN =	30
     28  0000 ????
     29 U0098 ????				      seg.u	vars	;	  uninitialized segment
     30 U0080					      org	$80	;	  origin set at base of ram 
     31 U0080
     32 U0080							; define variables
     33 U0080		       00	   pf_segment ds	1
     34 U0081		       00	   pf_segindex ds	1
     35 U0082		       00 00	   m_y	      ds	2	;	  missile y pos
     36 U0084		       00	   p_x	      ds	1
     37 U0085		       00 00	   mBearing   ds	2	;	  (0-15) 16 angles 22.5 deg apart
     38 U0087		       00 00	   mBearingOld ds	2	;	  org bearing of ball before bounce
     39 U0089		       00 00	   collisionCnt ds	2	;	  collision count
     40 U008b		       00	   pfCnt      ds	1	;	  playfield index
     41 U008c		       00	   scoreCnt   ds	1
     42 U008d		       00	   mCollision ds	1	;	  current players collision register value
     43 U008e		       00	   r_seed     ds	1	;	  random seed
     44 U008f		       00 00	   snd_on     ds	2	;	  1 byte per channel - >0 if sound is playing
     45 U0091		       00	   score      ds	1	;	  value to display
     46 U0092		       00 00	   digitIdx   ds	2	;	  index for digit to use within the data table
     47 U0094		       00	   temp       ds	1	;	  general temp address to swap out values
     48 U0095		       00	   voutCount  ds	1	;	  number of cycles left for vout
     49 U0096		       00	   soutCount  ds	1	;	  number of cycles left for sount (the score)
     50 U0097		       00	   showEarsCnt ds	1	;	  the number of frames left to show the ears	 
     51 U0098
     52 U0098
     53  10000 ????				       seg	main	;	  start of main segment
     54  f000					      org	$F000
     55  f000
     56  f000				   reset
      0  f000					      CLEAN_START		;	  ouput: all ram/registers 0
      1  f000		       78		      sei
      2  f001		       d8		      cld
      3  f002
      4  f002				  -	      IFNCONST	NO_ILLEGAL_OPCODES
      5  f002				  -	      lxa	#0
      6  f002					      ELSE
      7  f002		       a2 00		      ldx	#0
      8  f004		       8a		      txa
      9  f005					      ENDIF
     10  f005		       a8		      tay
     11  f006		       ca	   .CLEAR_STACK dex
     12  f007		       9a		      txs
     13  f008		       48		      pha
     14  f009		       d0 fb		      bne	.CLEAR_STACK
     15  f00b
     58  f00b
     59  f00b							; generate a random seed from the interval timer
     60  f00b		       ad 84 02 	      lda	INTIM	;	  unknown value to use as an initial random seed
     61  f00e		       85 8e		      sta	r_seed
     62  f010
     63  f010		       a9 17		      lda	#%00010111	;	  missiles and player double wide
     64  f012		       85 04		      sta	NUSIZ0
     65  f014		       85 05		      sta	NUSIZ1
     66  f016
     67  f016							; set area values
     68  f016		       a9 15		      lda	#%00010101	;	  playfield to reflect 
     69  f018		       85 0a		      sta	CTRLPF
     70  f01a
     71  f01a				   softReset
     72  f01a
     73  f01a
     74  f01a		       a9 00		      lda	#0
     75  f01c		       85 91		      sta	score	;	  reset the score
     76  f01e		       85 97		      sta	showEarsCnt
     77  f020
     78  f020		       a9 4b		      lda	#MISSILE_YPOS
     79  f022		       85 82		      sta	m_y
     80  f024		       85 83		      sta	m_y+1
     81  f026
     82  f026		       a2 00		      ldx	#0
     83  f028		       a9 2b		      lda	#MISSILE0_XPOS	;	  m0 horizontal position pulling 0 from x
     84  f02a		       20 05 f2 	      jsr	initObject	;	  m0 starting position
     85  f02d
     86  f02d		       a2 01		      ldx	#1
     87  f02f		       a9 74		      lda	#MISSILE1_XPOS	;	  m1 horizontal position
     88  f031		       20 05 f2 	      jsr	initObject	;	  m1 starting position
     89  f034
     90  f034							; lock the graphic object positions
     91  f034		       85 02		      sta	WSYNC
     92  f036							;--------------------------------------
     93  f036		       85 2a		      sta	HMOVE	;	  strobe horizontal move to set fine positions	
     94  f038
     95  f038		       a9 00		      lda	#0
     96  f03a		       85 20		      sta	HMP0	;	  clear p0 h movement
     97  f03c		       85 21		      sta	HMP1
     98  f03e		       85 81		      sta	pf_segindex	;	  first index of current playfield segment
     99  f040
    100  f040		       a9 1e		      lda	#YELLOW
    101  f042		       85 06		      sta	COLUP0
    102  f044		       a9 a6		      lda	#BLUE
    103  f046		       85 07		      sta	COLUP1
    104  f048
    105  f048				   nextFrame
      0  f048					      VERTICAL_SYNC		;	  output: a = 0; 3 scanlines
      1  f048		       a9 0e		      lda	#%1110
      2  f04a		       85 02	   .VSLP1     sta	WSYNC
      3  f04c		       85 00		      sta	VSYNC
      4  f04e		       4a		      lsr
      5  f04f		       d0 f9		      bne	.VSLP1
    107  f051
    108  f051				   verticalBlank
    109  f051		       a2 2b		      ldx	#VBLANKTIME	;	  defined/precalculated in build.h
    110  f053		       8e 96 02 	      stx	TIM64T	;	  set 64-clock for 43 intervals. 
    111  f056
    112  f056							; calculate the score
    113  f056		       a5 91		      lda	score	; 2	  get the score   
    114  f058		       18		      clc		; 2	  clear the carry bit so it's not added in adc 
    115  f059		       48		      pha		; 3	  push the score to the stack 
    116  f05a		       29 0f		      and	#$0f	; 2	  mask the first nibble 
    117  f05c		       85 94		      sta	temp	; 3	  store the first nibble in temp
    118  f05e		       0a		      asl		; 2	  shift left (multiply by 2)
    119  f05f		       0a		      asl		; 2	  shift left (multiply by 2)
    120  f060		       65 94		      adc	temp	; 2	  add the first nibble to the result 
    121  f062		       85 92		      sta	digitIdx	; 3	  store calculated index
    122  f064		       68		      pla		; 4	  pull original score from stack
    123  f065		       29 f0		      and	#$f0	; 2	  mask the second nibble
    124  f067		       4a		      lsr		; 2	  shift right (divide by 2)
    125  f068		       4a		      lsr		; 2	  shift right (divide by 2)
    126  f069		       85 94		      sta	temp	; 3	  store calculated index
    127  f06b		       4a		      lsr		; 2	  shift right (divide by 2)
    128  f06c		       4a		      lsr		; 2	  shift right (divide by 2)
    129  f06d		       65 94		      adc	temp	; 2	  add 
    130  f06f		       85 93		      sta	digitIdx+1	; 3	  store the index in the address digitIdx+1.  
    131  f071
    132  f071							; process the sound channels to turn off volume when counter runs out
    133  f071		       20 64 f2 	      jsr	snd_process
    134  f074
    135  f074							; we're checking the collision between m0+pf, m1+pf, and m1+m2
    136  f074		       a2 01		      ldx	#1	;	  start with m1 and work down to m0
    137  f076				   nextCollObject
    138  f076
    139  f076							; collision detection
    140  f076		       b5 00		      lda	CXM0P,X	;	  missile collision with player 
    141  f078		       15 04		      ora	CXM0FB,x	;	  missile collision with playfield?
    142  f07a		       85 8d		      sta	mCollision
    143  f07c		       a9 c0		      lda	#%11000000
    144  f07e		       25 8d		      and	mCollision
    145  f080		       d0 07		      bne	collision
    146  f082		       a9 00		      lda	#0	;	  no collision, set collision count to 0
    147  f084		       95 89		      sta	collisionCnt,x
    148  f086		       4c d5 f0 	      jmp	no_collision	;	  bypass collision handling
    149  f089
    150  f089							; when a collision occures we try to reflect to a vertical bearing. If on the
    151  f089							; next frame we're still registering a collision then we try a horizontal 
    152  f089							; bearing. If it's STILL registering a collision then we reflect it back 180
    153  f089							; degrees from the original pre-bounce bearing.
    154  f089
    155  f089				   collision
    156  f089							; a collision occured
    157  f089		       b5 89		      lda	collisionCnt,x	;	  times collision occured consecutively
    158  f08b		       d0 30		      bne	col_on	;	  branch if collisions are already ongoing
    159  f08d
    160  f08d		       b5 04		      lda	CXM0FB,x
    161  f08f		       29 c0		      and	#%11000000
    162  f091		       f0 03		      beq	doneM0FB
    163  f093		       20 31 f2 	      jsr	sndPlayBounce	;	  missile collision with pf
    164  f096				   doneM0FB
    165  f096		       b5 00		      lda	CXM0P,X	;	  missile collision with player
    166  f098		       29 c0		      and	#%11000000
    167  f09a		       f0 0c		      beq	doneM0P
    168  f09c		       f8		      sed		;	  set decimal flag
    169  f09d		       18		      clc
    170  f09e		       a5 91		      lda	score
    171  f0a0		       69 01		      adc	#1
    172  f0a2		       85 91		      sta	score
    173  f0a4		       d8		      cld		;	  clear decimal flag
    174  f0a5		       20 53 f2 	      jsr	sndPlayPaddle
    175  f0a8				   doneM0P
    176  f0a8		       b5 85		      lda	mBearing,x	;	  get the current bearing
    177  f0aa		       95 87		      sta	mBearingOld,x	;	  store current mBearing
    178  f0ac		       49 ff		      eor	#$FF	;	  reverse our bearings 
    179  f0ae		       95 85		      sta	mBearing,x
    180  f0b0		       f6 85		      inc	mBearing,x	;	  additive reverse
    181  f0b2		       b5 85		      lda	mBearing,x
    182  f0b4		       29 03		      and	#$03	;	  is bearing N,S,E,W?
    183  f0b6		       d0 02		      bne	col_no_adj
    184  f0b8		       f6 85		      inc	mBearing,x	;	  inc bearing offset to prevent cont reflection
    185  f0ba
    186  f0ba				   col_no_adj
    187  f0ba		       4c d3 f0 	      jmp	collision_done
    188  f0bd
    189  f0bd				   col_on
    190  f0bd		       c9 01		      cmp	#$01	;	  check collisionCnt
    191  f0bf		       f0 0b		      beq	revBearing	;	  first collision in series
    192  f0c1		       c9 03		      cmp	#$03	;	  check collisionCnt
    193  f0c3		       90 0e		      bcc	collision_done	;	  second/third collision in series
    194  f0c5		       d0 0c		      bne	collision_done	;	  more than three collisions in series
    195  f0c7		       b5 87		      lda	mBearingOld,x	;	  retrieve pre-bounce bearing
    196  f0c9		       4c ce f0 	      jmp	revOrgBearing	;	  reverse bearing it 180 degrees
    197  f0cc
    198  f0cc				   revBearing		;	  reverse altered bearing
    199  f0cc		       b5 85		      lda	mBearing,x
    200  f0ce				   revOrgBearing		;	  reverse original bearing
    201  f0ce		       18		      clc		;	  clear carry so not included in adc
    202  f0cf		       69 08		      adc	#$08	;	  reverse bearing by 180 degrees
    203  f0d1		       95 85		      sta	mBearing,x
    204  f0d3
    205  f0d3				   collision_done
    206  f0d3		       f6 89		      inc	collisionCnt,x	;	  increment the number of consecutive collisions
    207  f0d5				   no_collision
    208  f0d5
    209  f0d5		       20 e4 f1 	      jsr	moveBall
    210  f0d8
    211  f0d8		       ca		      dex		;	  check next object
    212  f0d9		       10 9b		      bpl	nextCollObject	;	  when result is positive move on to p0
    213  f0db
    214  f0db		       a0 ff		      ldy	#255	;	  prime for first playfield segment 
    215  f0dd		       84 80		      sty	pf_segment
    216  f0df		       a2 58		      ldx	#VOUTLINES	;	  defined in build.h
    217  f0e1		       86 8b		      stx	pfCnt	;	  2 line kernel (2lk) so count is 1/2 pf height
    218  f0e3
    219  f0e3		       85 02		      sta	WSYNC
    220  f0e5							;--------------------------------------
    221  f0e5		       85 2a		      sta	HMOVE	;	  set fine horizontal positioning
    222  f0e7		       85 2c		      sta	CXCLR	;	  clear all the collision registers
    223  f0e9
    224  f0e9		       a9 0f		      lda	#SOUTLINES	; 2	
    225  f0eb		       85 96		      sta	soutCount	; 3	      
    226  f0ed
    227  f0ed				   checktimer
    228  f0ed		       ad 84 02 	      lda	INTIM	;	  time remaining (or past)
    229  f0f0		       d0 fb		      bne	checktimer	;	  burn remaining cycles
    230  f0f2
    231  f0f2		       85 02		      sta	WSYNC
    232  f0f4							;--------------------------------------
    233  f0f4		       85 01		      sta	VBLANK	;	  set vertical blank off
    234  f0f6
    235  f0f6		       a5 97		      lda	showEarsCnt
    236  f0f8		       f0 1b		      beq	showScore
    237  f0fa		       a2 04		      ldx	#$4
    238  f0fc		       a9 46		      lda	#RED
    239  f0fe		       85 08		      sta	COLUPF
    240  f100				   showEars
    241  f100		       bd 11 f3 	      lda	ears,x
    242  f103		       85 0e		      sta	PF1
    243  f105		       85 02		      sta	WSYNC
    244  f107							;--------------------------------------
    245  f107		       85 02		      sta	WSYNC
    246  f109							;--------------------------------------
    247  f109		       85 02		      sta	WSYNC
    248  f10b							;--------------------------------------
    249  f10b		       ca		      dex
    250  f10c		       10 f2		      bpl	showEars
    251  f10e		       c6 97		      dec	showEarsCnt
    252  f110
    253  f110		       85 02		      sta	WSYNC
    254  f112							;--------------------------------------
    255  f112		       4c 56 f1 	      jmp	vout
    256  f115
    257  f115
    258  f115				   showScore
    259  f115		       a0 03		      ldy	#$3
    260  f117		       a9 0e		      lda	#WHITE
    261  f119		       85 08		      sta	COLUPF
    262  f11b				   voutscore
    263  f11b		       a6 92		      ldx	digitIdx	; 2
    264  f11d		       bd 74 f3 	      lda	digits,x	; 2	  load the digit graphic for this scanline     
    265  f120		       29 0f		      and	#$0f	; 2	  mask off first nibble so only see one number
    266  f122		       85 94		      sta	temp	; 3
    267  f124		       a6 93		      ldx	digitIdx+1	; 2
    268  f126		       bd 74 f3 	      lda	digits,x	; 2
    269  f129		       29 f0		      and	#$f0	; 2
    270  f12b		       05 94		      ora	temp	; 2
    271  f12d		       a2 00		      ldx	#$0	; 2	  PF1 is displayed. clear before it repeats
    272  f12f		       86 0e		      stx	PF1	; 3
    273  f131		       88		      dey		; 2
    274  f132		       85 02		      sta	WSYNC	; 3
    275  f134							;--------------------------------------
    276  f134		       d0 06		      bne	cont	; 2/3
    277  f136		       a0 03		      ldy	#3	; 2
    278  f138		       e6 92		      inc	digitIdx	; 2	  inc digit offset to get next line of graphic
    279  f13a		       e6 93		      inc	digitIdx+1	; 2
    280  f13c				   cont
    281  f13c		       85 0e		      sta	PF1	; 3	  write the digit graphic to the playfield
    282  f13e		       c6 96		      dec	soutCount	; 5
    283  f140		       d0 d9		      bne	voutscore	; 2/3	       
    284  f142
      0  f142					      SLEEP	20	; 20	  we need some padding before clearing PF1	   
      1  f142				   .CYCLES    SET	20
      2  f142
      3  f142				  -	      IF	.CYCLES < 2
      4  f142				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f142				  -	      ERR
      6  f142					      ENDIF
      7  f142
      8  f142				  -	      IF	.CYCLES & 1
      9  f142				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  f142				  -	      nop	0
     11  f142				  -	      ELSE
     12  f142				  -	      bit	VSYNC
     13  f142				  -	      ENDIF
     14  f142				  -.CYCLES    SET	.CYCLES - 3
     15  f142					      ENDIF
     16  f142
     17  f142					      REPEAT	.CYCLES / 2
     18  f142		       ea		      nop
     17  f142					      REPEND
     18  f143		       ea		      nop
     17  f143					      REPEND
     18  f144		       ea		      nop
     17  f144					      REPEND
     18  f145		       ea		      nop
     17  f145					      REPEND
     18  f146		       ea		      nop
     17  f146					      REPEND
     18  f147		       ea		      nop
     17  f147					      REPEND
     18  f148		       ea		      nop
     17  f148					      REPEND
     18  f149		       ea		      nop
     17  f149					      REPEND
     18  f14a		       ea		      nop
     17  f14a					      REPEND
     18  f14b		       ea		      nop
     19  f14c					      REPEND
    286  f14c
    287  f14c		       a9 00		      lda	#$0	; 2
    288  f14e		       85 0e		      sta	PF1	; 3	  clear PF1  
    289  f150
    290  f150		       a9 46		      lda	#RED
    291  f152		       85 08		      sta	COLUPF
    292  f154		       85 02		      sta	WSYNC	; 3
    293  f156							;--------------------------------------
    294  f156
    295  f156				   vout
    296  f156		       46 81		      lsr	pf_segindex	; 5	5 
    297  f158		       d0 06		      bne	skipx	; 3	8 
    298  f15a		       e6 80		      inc	pf_segment	; 5   13
    299  f15c		       a2 0f		      ldx	#PFSEGHEIGHT	; 2   15      
    300  f15e		       86 81		      stx	pf_segindex	; 3   18
    301  f160				   skipx
    302  f160		       a4 80		      ldy	pf_segment	; 2   20
    303  f162		       b9 18 f3 	      lda	PF0_data_cat,y	; 4   24 
    304  f165		       85 02		      sta	WSYNC	; 3   27	    
    305  f167							;--------------------------------------
    306  f167
    307  f167							; draw playfield
    308  f167		       85 0d		      sta	PF0	; 3   29
    309  f169		       b9 30 f3 	      lda	PF1_data_cat,y	; 4   34
    310  f16c		       85 0e		      sta	PF1	; 3   37
    311  f16e		       b9 48 f3 	      lda	PF2_data_cat,y	; 4   41
    312  f171		       85 0f		      sta	PF2	; 3   44
    313  f173		       a9 3c		      lda	#ORANGE	; 2   46 defined in build.h 
    314  f175		       85 09		      sta	COLUBK	; 3   49
    315  f177
    316  f177		       a0 00		      ldy	#0	; 2   51
    317  f179		       a2 00		      ldx	#0
    318  f17b		       b9 82 00 	      lda	m_y,y	; 4   57 load ball y pos
    319  f17e		       c5 8b		      cmp	pfCnt	; 2   59 compare y pos to playfield counter
    320  f180		       d0 02		      bne	noM1	; 3   62 if not same continue with blank player graphic
    321  f182		       a2 02		      ldx	#%00000010
    322  f184				   noM1
    323  f184		       96 1d		      stx	ENAM0,y	; 4   70 enable current player graphic
    324  f186		       a2 00		      ldx	#0
    325  f188		       c8		      iny
    326  f189		       b9 82 00 	      lda	m_y,y	; 4   57 load ball y pos
    327  f18c		       c5 8b		      cmp	pfCnt	; 2   59 compare y pos to playfield counter
    328  f18e		       d0 02		      bne	noM0	; 3   62 if not same continue with blank player graphic
    329  f190		       a2 02		      ldx	#%00000010
    330  f192				   noM0
    331  f192		       96 1d		      stx	ENAM0,y	; 4   70 enable current player graphic
    332  f194		       85 02		      sta	WSYNC	; 3  149
    333  f196							;--------------------------------------
    334  f196
    335  f196		       a2 00		      ldx	#0	; 2  151
    336  f198		       a5 8b		      lda	pfCnt	; 3  154
    337  f19a		       c9 05		      cmp	#PADDLE_POS	; 2  156
    338  f19c		       10 03		      bpl	noP0	;2/3 159
    339  f19e		       ae 00 f3 	      ldx	paddle	; 3  162
    340  f1a1				   noP0
    341  f1a1		       86 1b		      stx	GRP0	; 3  165
    342  f1a3
    343  f1a3		       c6 8b		      dec	pfCnt	; 5  170
    344  f1a5		       d0 af		      bne	vout	;2/3 173
    345  f1a7
    346  f1a7		       85 02		      sta	WSYNC	;	  end kernel with a clean scan line
    347  f1a9							;--------------------------------------
    348  f1a9		       a9 02		      lda	#$2	;	  set D1 = 1 to initiate VBLANK
    349  f1ab		       85 01		      sta	VBLANK	;	  turn off the beam
    350  f1ad
    351  f1ad		       a9 00		      lda	#$0
    352  f1af		       85 0d		      sta	PF0
    353  f1b1		       85 0e		      sta	PF1
    354  f1b3		       85 0f		      sta	PF2
    355  f1b5		       85 09		      sta	COLUBK
    356  f1b7		       85 1d		      sta	ENAM0
    357  f1b9		       85 1e		      sta	ENAM1
    358  f1bb		       85 1b		      sta	GRP0
    359  f1bd
    360  f1bd							; ---- overscan (30 scanlines)
    361  f1bd		       a2 23		      ldx	#OVERSCANTIME	;	  
    362  f1bf		       8e 96 02 	      stx	TIM64T	;	  Set a count of 35 with 64-clock interval
    363  f1c2
    364  f1c2		       a9 00		      lda	#0	;	  reset P0 HMOVE
    365  f1c4		       85 20		      sta	HMP0
    366  f1c6
    367  f1c6							; right moves 
    368  f1c6		       a9 80		      lda	#%10000000
    369  f1c8		       2c 80 02 	      bit	SWCHA
    370  f1cb		       d0 04		      bne	.sRtDone
    371  f1cd		       a9 c0		      lda	#%11000000
    372  f1cf		       85 20		      sta	HMP0
    373  f1d1				   .sRtDone
    374  f1d1
    375  f1d1							; left switches
    376  f1d1		       a9 40		      lda	#%01000000
    377  f1d3		       2c 80 02 	      bit	SWCHA
    378  f1d6		       d0 04		      bne	.sLfDone
    379  f1d8		       a9 40		      lda	#%01000000
    380  f1da		       85 20		      sta	HMP0
    381  f1dc				   .sLfDone
    382  f1dc
    383  f1dc							; overscan remainder timer -----------
    384  f1dc				   overscan_timer
    385  f1dc		       ae 84 02 	      ldx	INTIM
    386  f1df		       d0 fb		      bne	overscan_timer
    387  f1e1		       4c 48 f0 	      jmp	nextFrame	;	  jump back up to start the next frame
    388  f1e4
    389  f1e4				   moveBall   subroutine
    390  f1e4							; move the ball
    391  f1e4		       b5 85		      lda	mBearing,x
    392  f1e6		       29 0f		      and	#$0F	;	  strip the high nibble
    393  f1e8		       a8		      tay
    394  f1e9		       b9 01 f3 	      lda	bearingOffset,y	;	  load x/y offsets based on the current bearing
    395  f1ec		       95 22		      sta	HMM0,x	;	  horizontally move the current missile object
    396  f1ee							;	  update balls horizontal motion register which
    397  f1ee							;	  uses the high nibble where the x offset is
    398  f1ee							;	  stored.
    399  f1ee		       29 0f		      and	#$0F	;	  strip out high nibble which leave only offset
    400  f1f0		       38		      sec		;	  set the carry flag
    401  f1f1		       e9 08		      sbc	#$08	;	  subtract 8 for 4bit 2's completment +/-
    402  f1f3		       18		      clc		;	  clear carry flag so it's not used in adc
    403  f1f4		       75 82		      adc	m_y,x	;	  add y offset to current y position
    404  f1f6		       c9 80		      cmp	#128
    405  f1f8		       90 08		      bcc	ballactive	;	  is the ball still in the playfield?
    406  f1fa		       20 42 f2 	      jsr	sndPlayRespawn	;	  use the p0/p1 value in x for channel
    407  f1fd		       20 05 f2 	      jsr	initObject	;	  respawn the missile
    408  f200
    409  f200		       a9 4b		      lda	#MISSILE_YPOS
    410  f202				   ballactive
    411  f202		       95 82		      sta	m_y,x	;	  store the new y position
    412  f204
    413  f204		       60		      rts
    414  f205
    415  f205				   initObject subroutine
    416  f205
    417  f205							; 'randomly' select an initial bearing (direction)
    418  f205		       20 15 f2 	      jsr	galoisLfsrRand	;	  no need to store the seed for this one
    419  f208		       29 0f		      and	#$0F	;	  limit the value to 0-15
    420  f20a		       95 85		      sta	mBearing,x
    421  f20c		       a9 1e		      lda	#SHOWEARS_LEN
    422  f20e		       85 97		      sta	showEarsCnt
    423  f210		       a9 00		      lda	#0
    424  f212		       85 91		      sta	score	;	  reset score
    425  f214		       60		      rts
    426  f215
    427  f215							; Galois 8-bit Linear Feedback Shift Registers
    428  f215							; https://samiam.org/blog/20130617.html
    429  f215				   galoisLfsrRand subroutine
    430  f215		       a5 8e		      lda	r_seed	;	  keep calling funtion to for better entropy
    431  f217		       4a		      lsr		;	  shift right
    432  f218		       90 02		      bcc	.noeor0	;	  if carry 1, then exclusive OR the bits
    433  f21a		       49 d4		      eor	#$D4	;	  d4 tap (11010100)
    434  f21c				   .noeor0
    435  f21c		       85 8e		      sta	r_seed
    436  f21e		       60		      rts
    437  f21f
    438  f21f							; -----------------------------------------------------------------------------
    439  f21f							; PositionX
    440  f21f							; A - Horizontal position of the object
    441  f21f							; X - Object to position
    442  f21f							;   0 - Player 0
    443  f21f							;   1 - Player 1
    444  f21f							;   2 - Missile 0
    445  f21f							;   3 - Missile 1
    446  f21f							;   4 - Ball
    447  f21f							; -----------------------------------------------------------------------------
    448  f21f
    449  f21f				   PositionX  subroutine
    450  f21f		       38		      sec		; 2	2 set the carry flag
    451  f220		       85 02		      sta	WSYNC	; 3	5 start a new line
    452  f222							;--------------------------------------
    453  f222				   .divide
    454  f222		       e9 0f		      sbc	#15	; 2	2 subtract 15
    455  f224		       b0 fc		      bcs	.divide	; 2	4 branch until negative
    456  f226		       49 07		      eor	#7	; 2	6 calculate fine offset
    457  f228		       0a		      asl		; 2	8 shift left
    458  f229		       0a		      asl		; 2   10
    459  f22a		       0a		      asl		; 2   12
    460  f22b		       0a		      asl		; 2   14
    461  f22c		       95 20		      sta	HMP0,x	; 5   19 set fine offset
    462  f22e		       95 10		      sta	RESP0,x	; 4   23 set coarse position
    463  f230		       60		      rts		; 6   29 return
    464  f231
    465  f231							; cues a sound to play. sets audio registers based on table lookup sndbank.
    466  f231							; parameters: x = channel (0|1), y = sound to play
    467  f231				   sndPlayBounce
    468  f231		       a9 0c		      lda	#$0C
    469  f233		       85 15		      sta	AUDC0	;	  audio control   
    470  f235		       a9 05		      lda	#$05
    471  f237		       85 19		      sta	AUDV0	;	  audio volume
    472  f239		       a9 0f		      lda	#$0F
    473  f23b		       85 17		      sta	AUDF0	;	  audio frequence
    474  f23d		       a9 01		      lda	#01
    475  f23f		       85 8f		      sta	snd_on	;	  len of audio in frames (>0 = sound on)
    476  f241		       60		      rts
    477  f242
    478  f242				   sndPlayRespawn
    479  f242		       a9 02		      lda	#$02
    480  f244		       85 16		      sta	AUDC1	;	  audio control   
    481  f246		       a9 14		      lda	#$14
    482  f248		       85 1a		      sta	AUDV1	;	  audio volume
    483  f24a		       a9 05		      lda	#$05
    484  f24c		       85 18		      sta	AUDF1	;	  audio frequence
    485  f24e		       a9 14		      lda	#20
    486  f250		       85 90		      sta	snd_on+1	;	  len of audio in frames (>0 = sound on)
    487  f252		       60		      rts
    488  f253
    489  f253				   sndPlayPaddle
    490  f253		       a9 0e		      lda	#$0E
    491  f255		       85 15		      sta	AUDC0	;	  audio control   
    492  f257		       a9 05		      lda	#$05
    493  f259		       85 19		      sta	AUDV0	;	  audio volume
    494  f25b		       a9 03		      lda	#$03
    495  f25d		       85 17		      sta	AUDF0	;	  audio frequence
    496  f25f		       a9 04		      lda	#04
    497  f261		       85 8f		      sta	snd_on	;	  len of audio in frames (>0 = sound on)
    498  f263		       60		      rts
    499  f264
    500  f264							; process sound channels to turn off volume when sound length counter runs out
    501  f264				   snd_process
    502  f264		       a2 01		      ldx	#1	;	  channel to process, start with channel 1
    503  f266				   snd_ch
    504  f266		       b5 8f		      lda	snd_on,x	;	  get sound length counter for this channel
    505  f268		       f0 08		      beq	snd_done	;	  are we playing a sound? a>1 
    506  f26a		       d6 8f		      dec	snd_on,x	;	  yes, decrese the sound length counter for channel
    507  f26c		       d0 04		      bne	snd_cont	;	  did we reach the end of the sound length?
    508  f26e		       a9 00		      lda	#0	;	  yes
    509  f270		       95 19		      sta	AUDV0,x	;	  turn off the volume for this channel 
    510  f272				   snd_done
    511  f272				   snd_cont
    512  f272		       ca		      dex		;	  do it again for channel 0
    513  f273		       f0 f1		      beq	snd_ch
    514  f275		       60		      rts
    515  f276
    516  f300		       00 00 00 00*	      align	$100	;	  align data
    517  f300
    518  f300				   paddle
    519  f300		       ff		      .byte.b	#%11111111
    520  f301
    521  f301				   bearingOffset		;	  index  x-move  y-move
    522  f301		       e0		      .byte.b	#%11100000	;	    0	  -2	   0	
    523  f302		       e7		      .byte.b	#%11100111	;	    1	  -2	  -2	
    524  f303		       e6		      .byte.b	#%11100110	;	    2	  -2	  -4	
    525  f304		       f6		      .byte.b	#%11110110	;	    3	  -1	  -4	
    526  f305		       06		      .byte.b	#%00000110	;	    4	   0	  -4	
    527  f306		       16		      .byte.b	#%00010110	;	    5	  +1	  -4	
    528  f307		       26		      .byte.b	#%00100110	;	    6	  +2	  -4	
    529  f308		       27		      .byte.b	#%00100111	;	    7	  +2	  -2	
    530  f309		       28		      .byte.b	#%00101000	;	    8	  +2	   0	
    531  f30a		       29		      .byte.b	#%00101001	;	    9	  +2	  +2	
    532  f30b		       2a		      .byte.b	#%00101010	;	   10	  +2	  +4	
    533  f30c		       1a		      .byte.b	#%00011010	;	   11	  +1	  +4	
    534  f30d		       09		      .byte.b	#%00001001	;	   12	   0	  +2	
    535  f30e		       fa		      .byte.b	#%11111010	;	   13	  -1	  +4	
    536  f30f		       ea		      .byte.b	#%11101010	;	   14	  -2	  +4	
    537  f310		       e9		      .byte.b	#%11101001	;	   15	  -2	  +2  
    538  f311
    539  f311				   ears
    540  f311		       f9		      .byte.b	%11111001
    541  f312		       fa		      .byte.b	%11111010
    542  f313		       74		      .byte.b	%01110100
    543  f314		       28		      .byte.b	%00101000
    544  f315		       18		      .byte.b	%00011000
    545  f316
------- FILE playfields/pf_cat.h LEVEL 2 PASS 2
      0  f316					      include	"playfields/pf_cat.h"
      1  f316				   PF_col_cat
      2  f316		       46		      .byte.b	#$46	; foreground
      3  f317		       00		      .byte.b	#$00	; background
      4  f318
      5  f318				   PF0_data_cat
      6  f318		       f0		      .byte.b	#%11110000	;<- first
      7  f319		       10		      .byte.b	#%00010000
      8  f31a		       10		      .byte.b	#%00010000
      9  f31b		       10		      .byte.b	#%00010000
     10  f31c		       10		      .byte.b	#%00010000
     11  f31d		       10		      .byte.b	#%00010000
     12  f31e		       10		      .byte.b	#%00010000
     13  f31f		       10		      .byte.b	#%00010000
     14  f320		       10		      .byte.b	#%00010000
     15  f321		       10		      .byte.b	#%00010000
     16  f322		       10		      .byte.b	#%00010000
     17  f323		       10		      .byte.b	#%00010000
     18  f324		       10		      .byte.b	#%00010000
     19  f325		       10		      .byte.b	#%00010000
     20  f326		       10		      .byte.b	#%00010000
     21  f327		       10		      .byte.b	#%00010000
     22  f328		       10		      .byte.b	#%00010000
     23  f329		       10		      .byte.b	#%00010000
     24  f32a		       10		      .byte.b	#%00010000
     25  f32b		       10		      .byte.b	#%00010000
     26  f32c		       10		      .byte.b	#%00010000
     27  f32d		       10		      .byte.b	#%00010000
     28  f32e		       10		      .byte.b	#%00010000
     29  f32f		       10		      .byte.b	#%00010000	;<- last
     30  f330
     31  f330				   PF1_data_cat
     32  f330		       ff		      .byte.b	#%11111111	;<- first
     33  f331		       00		      .byte.b	#%00000000
     34  f332		       00		      .byte.b	#%00000000
     35  f333		       00		      .byte.b	#%00000000
     36  f334		       00		      .byte.b	#%00000000
     37  f335		       00		      .byte.b	#%00000000
     38  f336		       07		      .byte.b	#%00000111
     39  f337		       01		      .byte.b	#%00000001
     40  f338		       00		      .byte.b	#%00000000
     41  f339		       00		      .byte.b	#%00000000
     42  f33a		       60		      .byte.b	#%01100000
     43  f33b		       00		      .byte.b	#%00000000
     44  f33c		       60		      .byte.b	#%01100000
     45  f33d		       00		      .byte.b	#%00000000
     46  f33e		       60		      .byte.b	#%01100000
     47  f33f		       00		      .byte.b	#%00000000
     48  f340		       00		      .byte.b	#%00000000
     49  f341		       00		      .byte.b	#%00000000
     50  f342		       00		      .byte.b	#%00000000
     51  f343		       00		      .byte.b	#%00000000
     52  f344		       00		      .byte.b	#%00000000
     53  f345		       00		      .byte.b	#%00000000
     54  f346		       00		      .byte.b	#%00000000
     55  f347		       00		      .byte.b	#%00000000	;<- last
     56  f348
     57  f348				   PF2_data_cat
     58  f348		       ff		      .byte.b	#%11111111	;<- first
     59  f349		       00		      .byte.b	#%00000000
     60  f34a		       00		      .byte.b	#%00000000
     61  f34b		       00		      .byte.b	#%00000000
     62  f34c		       00		      .byte.b	#%00000000
     63  f34d		       00		      .byte.b	#%00000000
     64  f34e		       01		      .byte.b	#%00000001
     65  f34f		       00		      .byte.b	#%00000000
     66  f350		       00		      .byte.b	#%00000000
     67  f351		       00		      .byte.b	#%00000000
     68  f352		       00		      .byte.b	#%00000000
     69  f353		       80		      .byte.b	#%10000000
     70  f354		       00		      .byte.b	#%00000000
     71  f355		       00		      .byte.b	#%00000000
     72  f356		       00		      .byte.b	#%00000000
     73  f357		       00		      .byte.b	#%00000000
     74  f358		       00		      .byte.b	#%00000000
     75  f359		       00		      .byte.b	#%00000000
     76  f35a		       00		      .byte.b	#%00000000
     77  f35b		       00		      .byte.b	#%00000000
     78  f35c		       00		      .byte.b	#%00000000
     79  f35d		       00		      .byte.b	#%00000000
     80  f35e		       00		      .byte.b	#%00000000
     81  f35f		       00		      .byte.b	#%00000000	;<- last
------- FILE D:\src\u\s\emu\tests\bins\8blit\8blit-s04e01-Purrballs.asm
------- FILE digits.h LEVEL 2 PASS 2
      0  f360					      include	"digits.h"
      1  f360				   p0
      2  f360		       88		      .byte.b	%10001000
      3  f361		       88		      .byte.b	%10001000
      4  f362		       e8		      .byte.b	%11101000
      5  f363		       a8		      .byte.b	%10101000
      6  f364		       e8		      .byte.b	%11101000
      7  f365				   p1
      8  f365		       8e		      .byte.b	%10001110
      9  f366		       88		      .byte.b	%10001000
     10  f367		       ee		      .byte.b	%11101110
     11  f368		       a2		      .byte.b	%10100010
     12  f369		       ee		      .byte.b	%11101110
     13  f36a				   p2
     14  f36a		       8e		      .byte.b	%10001110
     15  f36b		       82		      .byte.b	%10000010
     16  f36c		       e6		      .byte.b	%11100110
     17  f36d		       a2		      .byte.b	%10100010
     18  f36e		       ee		      .byte.b	%11101110
     19  f36f				   p3
     20  f36f		       82		      .byte.b	%10000010
     21  f370		       82		      .byte.b	%10000010
     22  f371		       ee		      .byte.b	%11101110
     23  f372		       aa		      .byte.b	%10101010
     24  f373		       ea		      .byte.b	%11101010
     25  f374
     26  f374
     27  f374
     28  f374							; 0 to 99 in 50 bytes
     29  f374							; 00 to FF in 75 bytes
     30  f374
     31  f374				   digits
     32  f374							; 00
     33  f374		       77		      .byte.b	%01110111
     34  f375		       55		      .byte.b	%01010101
     35  f376		       55		      .byte.b	%01010101
     36  f377		       55		      .byte.b	%01010101
     37  f378		       77		      .byte.b	%01110111
     38  f379							; 11
     39  f379		       11		      .byte.b	%00010001
     40  f37a		       11		      .byte.b	%00010001
     41  f37b		       11		      .byte.b	%00010001
     42  f37c		       11		      .byte.b	%00010001
     43  f37d		       11		      .byte.b	%00010001
     44  f37e							; 22
     45  f37e		       77		      .byte.b	%01110111
     46  f37f		       11		      .byte.b	%00010001
     47  f380		       77		      .byte.b	%01110111
     48  f381		       44		      .byte.b	%01000100
     49  f382		       77		      .byte.b	%01110111
     50  f383							; 33
     51  f383		       77		      .byte.b	%01110111
     52  f384		       11		      .byte.b	%00010001
     53  f385		       33		      .byte.b	%00110011
     54  f386		       11		      .byte.b	%00010001
     55  f387		       77		      .byte.b	%01110111
     56  f388							; 44
     57  f388		       55		      .byte.b	%01010101
     58  f389		       55		      .byte.b	%01010101
     59  f38a		       77		      .byte.b	%01110111
     60  f38b		       11		      .byte.b	%00010001
     61  f38c		       11		      .byte.b	%00010001
     62  f38d							; 55
     63  f38d		       77		      .byte.b	%01110111
     64  f38e		       44		      .byte.b	%01000100
     65  f38f		       77		      .byte.b	%01110111
     66  f390		       11		      .byte.b	%00010001
     67  f391		       77		      .byte.b	%01110111
     68  f392							; 66
     69  f392		       77		      .byte.b	%01110111
     70  f393		       44		      .byte.b	%01000100
     71  f394		       77		      .byte.b	%01110111
     72  f395		       55		      .byte.b	%01010101
     73  f396		       77		      .byte.b	%01110111
     74  f397							; 77
     75  f397		       77		      .byte.b	%01110111
     76  f398		       11		      .byte.b	%00010001
     77  f399		       11		      .byte.b	%00010001
     78  f39a		       11		      .byte.b	%00010001
     79  f39b		       11		      .byte.b	%00010001
     80  f39c							; 88
     81  f39c		       77		      .byte.b	%01110111
     82  f39d		       55		      .byte.b	%01010101
     83  f39e		       77		      .byte.b	%01110111
     84  f39f		       55		      .byte.b	%01010101
     85  f3a0		       77		      .byte.b	%01110111
     86  f3a1							; 99
     87  f3a1		       77		      .byte.b	%01110111
     88  f3a2		       55		      .byte.b	%01010101
     89  f3a3		       77		      .byte.b	%01110111
     90  f3a4		       11		      .byte.b	%00010001
     91  f3a5		       77		      .byte.b	%01110111
     92  f3a6							; AA
     93  f3a6		       22		      .byte.b	%00100010
     94  f3a7		       55		      .byte.b	%01010101
     95  f3a8		       77		      .byte.b	%01110111
     96  f3a9		       55		      .byte.b	%01010101
     97  f3aa		       55		      .byte.b	%01010101
     98  f3ab							; BB
     99  f3ab		       66		      .byte.b	%01100110
    100  f3ac		       55		      .byte.b	%01010101
    101  f3ad		       66		      .byte.b	%01100110
    102  f3ae		       55		      .byte.b	%01010101
    103  f3af		       66		      .byte.b	%01100110
    104  f3b0							; CC
    105  f3b0		       77		      .byte.b	%01110111
    106  f3b1		       44		      .byte.b	%01000100
    107  f3b2		       44		      .byte.b	%01000100
    108  f3b3		       44		      .byte.b	%01000100
    109  f3b4		       77		      .byte.b	%01110111
    110  f3b5							; DD
    111  f3b5		       66		      .byte.b	%01100110
    112  f3b6		       55		      .byte.b	%01010101
    113  f3b7		       55		      .byte.b	%01010101
    114  f3b8		       55		      .byte.b	%01010101
    115  f3b9		       66		      .byte.b	%01100110
    116  f3ba							; EE
    117  f3ba		       77		      .byte.b	%01110111
    118  f3bb		       44		      .byte.b	%01000100
    119  f3bc		       66		      .byte.b	%01100110
    120  f3bd		       44		      .byte.b	%01000100
    121  f3be		       77		      .byte.b	%01110111
    122  f3bf							; FF
    123  f3bf		       77		      .byte.b	%01110111
    124  f3c0		       44		      .byte.b	%01000100
    125  f3c1		       66		      .byte.b	%01100110
    126  f3c2		       44		      .byte.b	%01000100
    127  f3c3		       44		      .byte.b	%01000100
------- FILE D:\src\u\s\emu\tests\bins\8blit\8blit-s04e01-Purrballs.asm
    548  f3c4
    549  fffa					      org	$fffa
    550  fffa
    551  fffa		       00 f0		      .word.w	reset	;	  nmi ($fffa)
    552  fffc		       00 f0		      .word.w	reset	;	  reset ($fffc)
    553  fffe		       00 f0		      .word.w	reset	;	  irq ($fffe)
