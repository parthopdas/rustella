------- FILE D:\src\u\s\emu\tests\bins\8blit\8blit-s03e04-Regions-before-2.asm LEVEL 1 PASS 2
      1  fffe					      processor	6502	; S03E04 Regions (before 2)
      2  10000 ????						;
------- FILE vcs.h LEVEL 2 PASS 2
      0  10000 ????				       include	"vcs.h"	; Move the timings into a preprocessor variable so they're easily editable
      1  10000 ????						; VCS.H
      2  10000 ????						; Version 1.06, 06/SEP/2020
      3  10000 ????
      4  10000 ????		00 6a	    VERSION_VCS =	106
      5  10000 ????
      6  10000 ????						; THIS IS *THE* "STANDARD" VCS.H
      7  10000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8  10000 ????						; The latest version can be found at https://dasm-assembler.github.io/
      9  10000 ????						;
     10  10000 ????						; This file defines hardware registers and memory mapping for the
     11  10000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     12  10000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     13  10000 ????						; available at at https://dasm-assembler.github.io/
     14  10000 ????						;
     15  10000 ????						; Many thanks to the people who have contributed. If you find an issue with the
     16  10000 ????						; contents, or would like ot add something, please report as an issue at...
     17  10000 ????						; https://github.com/dasm-assembler/dasm/issues
     18  10000 ????
     19  10000 ????						;
     20  10000 ????						; Latest Revisions...
     21  10000 ????						; 1.06  05/SEP/2020	 Modified header/license and links to new versions
     22  10000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     23  10000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     24  10000 ????						;			    This will allow conditional code to verify VCS.H being
     25  10000 ????						;			    used for code assembly.
     26  10000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     27  10000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     28  10000 ????						;			 mirrored reading/writing differences.	This is more a 
     29  10000 ????						;			 readability issue, and binary compatibility with disassembled
     30  10000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     31  10000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     32  10000 ????						;			 which was broken by the use of segments in this file, as
     33  10000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     34  10000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     35  10000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     36  10000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     37  10000 ????						;						   it is safe to leave it undefined, and the base address will
     38  10000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     39  10000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     40  10000 ????						;			  - register definitions are now generated through assignment
     41  10000 ????						;			    in uninitialised segments.	This allows a changeable base
     42  10000 ????						;			    address architecture.
     43  10000 ????						; 1.0	22/MAR/2003		Initial release
     44  10000 ????
     45  10000 ????
     46  10000 ????						;-------------------------------------------------------------------------------
     47  10000 ????
     48  10000 ????						; TIA_BASE_ADDRESS
     49  10000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     50  10000 ????						; Normally 0, the base address should (externally, before including this file)
     51  10000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     52  10000 ????						; The reason is that this bankswitching scheme treats any access to locations
     53  10000 ????						; < $40 as a bankswitch.
     54  10000 ????
     55  10000 ????			   -	       IFNCONST	TIA_BASE_ADDRESS
     56  10000 ????			   -TIA_BASE_ADDRESS =	0
     57  10000 ????				       ENDIF
     58  10000 ????
     59  10000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     60  10000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     61  10000 ????						; *OR* by declaring the label before including this file, eg:
     62  10000 ????						; TIA_BASE_ADDRESS = $40
     63  10000 ????						;   include "vcs.h"
     64  10000 ????
     65  10000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     66  10000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     67  10000 ????						; for the mirrored ROM hardware registers.
     68  10000 ????
     69  10000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     70  10000 ????						; using the -D command-line switch, as required.  If the addresses are not defined, 
     71  10000 ????						; they defaut to the TIA_BASE_ADDRESS.
     72  10000 ????
     73  10000 ????			   -	       IFNCONST	TIA_BASE_READ_ADDRESS
     74  10000 ????			   -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     75  10000 ????				       ENDIF
     76  10000 ????
     77  10000 ????			   -	       IFNCONST	TIA_BASE_WRITE_ADDRESS
     78  10000 ????			   -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     79  10000 ????				       ENDIF
     80  10000 ????
     81  10000 ????						;-------------------------------------------------------------------------------
     82  10000 ????
     83 U002d ????				      SEG.U	TIA_REGISTERS_WRITE
     84 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     85 U0000
     86 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     87 U0000
     88 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     89 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     90 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     91 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     92 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     93 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     94 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     95 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     96 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     97 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     98 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     99 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    100 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    101 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    102 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    103 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    104 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    105 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    106 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    107 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    108 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    109 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    110 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    111 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    112 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    113 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    114 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    115 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    116 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    117 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    118 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    119 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    120 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    121 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    122 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    123 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    124 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    125 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    126 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    127 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    128 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    129 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    130 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    131 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    132 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    133 U002d
    134 U002d							;-------------------------------------------------------------------------------
    135 U002d
    136 U000e ????				      SEG.U	TIA_REGISTERS_READ
    137 U0000					      ORG	TIA_BASE_READ_ADDRESS
    138 U0000
    139 U0000							;											bit 7	 bit 6
    140 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    141 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    142 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    143 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    144 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    145 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    146 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    147 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    148 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    149 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    150 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    151 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    152 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    153 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    154 U000e
    155 U000e							;-------------------------------------------------------------------------------
    156 U000e
    157 U0298 ????				      SEG.U	RIOT
    158 U0280					      ORG	$280
    159 U0280
    160 U0280							; RIOT MEMORY MAP
    161 U0280
    162 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    163 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    164 U0281
    165 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    166 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    167 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    168 U0284		       00	   INTIM      ds	1	; $284		Timer output
    169 U0285
    170 U0285		       00	   TIMINT     ds	1	; $285
    171 U0286
    172 U0286							; Unused/undefined registers ($285-$294)
    173 U0286
    174 U0286		       00		      ds	1	; $286
    175 U0287		       00		      ds	1	; $287
    176 U0288		       00		      ds	1	; $288
    177 U0289		       00		      ds	1	; $289
    178 U028a		       00		      ds	1	; $28A
    179 U028b		       00		      ds	1	; $28B
    180 U028c		       00		      ds	1	; $28C
    181 U028d		       00		      ds	1	; $28D
    182 U028e		       00		      ds	1	; $28E
    183 U028f		       00		      ds	1	; $28F
    184 U0290		       00		      ds	1	; $290
    185 U0291		       00		      ds	1	; $291
    186 U0292		       00		      ds	1	; $292
    187 U0293		       00		      ds	1	; $293
    188 U0294
    189 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    190 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    191 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    192 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    193 U0298
    194 U0298							;-------------------------------------------------------------------------------
    195 U0298							; The following required for back-compatibility with code which does not use
    196 U0298							; segments.
    197 U0298
    198  0000 ????				      SEG
    199  0000 ????
    200  0000 ????						; EOF
------- FILE D:\src\u\s\emu\tests\bins\8blit\8blit-s03e04-Regions-before-2.asm
------- FILE macro.h LEVEL 2 PASS 2
      0  0000 ????				      include	"macro.h"	;  
      1  0000 ????						; MACRO.H
      2  0000 ????						; Version 1.09, 05/SEP/2020
      3  0000 ????
      4  0000 ????	       00 6d	   VERSION_MACRO =	109
      5  0000 ????
      6  0000 ????						;
      7  0000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8  0000 ????						; The latest version can be found at https://dasm-assembler.github.io/
      9  0000 ????						;
     10  0000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     11  0000 ????						; It is distributed as a companion machine-specific support package
     12  0000 ????						; for the DASM compiler.
     13  0000 ????						;
     14  0000 ????						; Many thanks to the people who have contributed. If you find an issue with the
     15  0000 ????						; contents, or would like ot add something, please report as an issue at...
     16  0000 ????						; https://github.com/dasm-assembler/dasm/issues
     17  0000 ????
     18  0000 ????
     19  0000 ????						; Latest Revisions...
     20  0000 ????						; 1.09  05/SEP/2020	 - updated license/links
     21  0000 ????
     22  0000 ????						; 1.08  13/JUL/2020	 - added use of LXA to CLEAN_START
     23  0000 ????						; 1.07  19/JAN/2020	 - correction to comment VERTICAL_SYNC
     24  0000 ????						; 1.06  03/SEP/2004	 - nice revision of VERTICAL_SYNC (Edwin Blink)
     25  0000 ????						; 1.05  14/NOV/2003	 - Added VERSION_MACRO equate (which will reflect 100x version #)
     26  0000 ????						;			   This will allow conditional code to verify MACRO.H being
     27  0000 ????						;			   used for code assembly.
     28  0000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     29  0000 ????						;
     30  0000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     31  0000 ????						;
     32  0000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     33  0000 ????						;			   (standardised macro for vertical synch code)
     34  0000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added. 
     35  0000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     36  0000 ????						; 1.0	22/MAR/2003		Initial release
     37  0000 ????
     38  0000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage, 
     39  0000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     40  0000 ????						;   If you do not allow illegal opcode usage, you must include this file 
     41  0000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     42  0000 ????						;   registers and require them to be defined first).
     43  0000 ????
     44  0000 ????						; Available macros...
     45  0000 ????						;   SLEEP n		 - sleep for n cycles
     46  0000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     47  0000 ????						;   CLEAN_START	 - set machine to known state on startup
     48  0000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     49  0000 ????
     50  0000 ????						;-------------------------------------------------------------------------------
     51  0000 ????						; SLEEP duration
     52  0000 ????						; Original author: Thomas Jentzsch
     53  0000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     54  0000 ????						; useful for code where precise timing is required.
     55  0000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     56  0000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     57  0000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     58  0000 ????
     59  0000 ????				      MAC	sleep
     60  0000 ????			   .CYCLES    SET	{1}
     61  0000 ????
     62  0000 ????				      IF	.CYCLES < 2
     63  0000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     64  0000 ????				      ERR
     65  0000 ????				      ENDIF
     66  0000 ????
     67  0000 ????				      IF	.CYCLES & 1
     68  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     69  0000 ????				      nop	0
     70  0000 ????				      ELSE
     71  0000 ????				      bit	VSYNC
     72  0000 ????				      ENDIF
     73  0000 ????			   .CYCLES    SET	.CYCLES - 3
     74  0000 ????				      ENDIF
     75  0000 ????
     76  0000 ????				      REPEAT	.CYCLES / 2
     77  0000 ????				      nop
     78  0000 ????				      REPEND
     79  0000 ????				      ENDM		;usage: SLEEP n (n>1)
     80  0000 ????
     81  0000 ????						;-------------------------------------------------------------------------------
     82  0000 ????						; VERTICAL_SYNC
     83  0000 ????						; revised version by Edwin Blink -- saves bytes!
     84  0000 ????						; Inserts the code required for a proper 3 scanline vertical sync sequence
     85  0000 ????						; Note: Alters the accumulator
     86  0000 ????
     87  0000 ????						; OUT: A = 0
     88  0000 ????
     89  0000 ????				      MAC	vertical_sync
     90  0000 ????				      lda	#%1110	; each '1' bits generate a VSYNC ON line (bits 1..3)
     91  0000 ????			   .VSLP1     sta	WSYNC	; 1st '0' bit resets Vsync, 2nd '0' bit exit loop
     92  0000 ????				      sta	VSYNC
     93  0000 ????				      lsr
     94  0000 ????				      bne	.VSLP1	; branch until VYSNC has been reset
     95  0000 ????				      ENDM
     96  0000 ????
     97  0000 ????						;-------------------------------------------------------------------------------
     98  0000 ????						; CLEAN_START
     99  0000 ????						; Original author: Andrew Davie
    100  0000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
    101  0000 ????						; Sets stack pointer to $FF, and all registers to 0
    102  0000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    103  0000 ????						; Use as very first section of code on boot (ie: at reset)
    104  0000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    105  0000 ????
    106  0000 ????				      MAC	clean_start
    107  0000 ????				      sei
    108  0000 ????				      cld
    109  0000 ????
    110  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
    111  0000 ????				      lxa	#0
    112  0000 ????				      ELSE
    113  0000 ????				      ldx	#0
    114  0000 ????				      txa
    115  0000 ????				      ENDIF
    116  0000 ????				      tay
    117  0000 ????			   .CLEAR_STACK dex
    118  0000 ????				      txs
    119  0000 ????				      pha
    120  0000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    121  0000 ????
    122  0000 ????				      ENDM
    123  0000 ????
    124  0000 ????						;-------------------------------------------------------
    125  0000 ????						; SET_POINTER
    126  0000 ????						; Original author: Manuel Rotschkar
    127  0000 ????						;
    128  0000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    129  0000 ????						;
    130  0000 ????						; Usage: SET_POINTER pointer, address
    131  0000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    132  0000 ????						;
    133  0000 ????						; Note: Alters the accumulator, NZ flags
    134  0000 ????						; IN 1: 2 byte RAM location reserved for pointer
    135  0000 ????						; IN 2: absolute address
    136  0000 ????
    137  0000 ????				      MAC	set_pointer
    138  0000 ????			   .POINTER   SET	{1}
    139  0000 ????			   .ADDRESS   SET	{2}
    140  0000 ????
    141  0000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    142  0000 ????				      STA	.POINTER	; Store in pointer
    143  0000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    144  0000 ????				      STA	.POINTER+1	; Store in pointer+1
    145  0000 ????
    146  0000 ????				      ENDM
    147  0000 ????
    148  0000 ????						;-------------------------------------------------------
    149  0000 ????						; BOUNDARY byte#
    150  0000 ????						; Original author: Denis Debro (borrowed from Bob Smith / Thomas)
    151  0000 ????						;
    152  0000 ????						; Push data to a certain position inside a page and keep count of how
    153  0000 ????						; many free bytes the programmer will have.
    154  0000 ????						;
    155  0000 ????						; eg: BOUNDARY 5    ; position at byte #5 in page
    156  0000 ????
    157  0000 ????			   .FREE_BYTES SET	0
    158  0000 ????				      MAC	boundary
    159  0000 ????				      REPEAT	256
    160  0000 ????				      IF	<. % {1} = 0
    161  0000 ????				      MEXIT
    162  0000 ????				      ELSE
    163  0000 ????			   .FREE_BYTES SET	.FREE_BYTES + 1
    164  0000 ????				      .byte	$00
    165  0000 ????				      ENDIF
    166  0000 ????				      REPEND
    167  0000 ????				      ENDM
    168  0000 ????
    169  0000 ????
    170  0000 ????						; EOF
------- FILE D:\src\u\s\emu\tests\bins\8blit\8blit-s03e04-Regions-before-2.asm
      5  0000 ????						;
      6  0000 ????						; This Episode on Youtube - https://youtu.be/o9wz3pdFU6o
      7  0000 ????						;
      8  0000 ????						; Become a Patron - https://patreon.com/8blit
      9  0000 ????						; 8blit Merch - https://8blit.myspreadshop.com/
     10  0000 ????						; Subscribe to 8Blit - https://www.youtube.com/8blit?sub_confirmation=1
     11  0000 ????						; Follow on Facebook - https://www.facebook.com/8Blit
     12  0000 ????						; Follow on Instagram - https://www.instagram.com/8blit
     13  0000 ????						; Visit the Website - https://www.8blit.com 
     14  0000 ????						;
     15  0000 ????						; Email - 8blit0@gmail.com
     16  0000 ????
     17  0000 ????						;
     18  0000 ????						; timing
     19  0000 ????	       00 2b	   VBLANKTIME =	43	; the number of 64 intervals for the vertical blank	   
     20  0000 ????	       00 60	   VOUTLINES  =	96	; height of our 2lk kernel playfield 192/2
     21  0000 ????	       00 23	   OVERSCANTIME =	35	; the number of 64 intervals for the overscan
     22  0000 ????	       00 0f	   PFSEGHEIGHT =	%00001111	; pf segements are 4 kernel lines in height
     23  0000 ????
     24  0000 ????						; color
     25  0000 ????	       00 46	   RED	      =	$46
     26  0000 ????	       00 3c	   ORANGE     =	$3c
     27  0000 ????	       00 1e	   YELLOW     =	$1e
     28  0000 ????	       00 a6	   BLUE       =	$a6
     29  0000 ????
     30 U008f ????				      seg.u	vars	; uninitialized segment
     31 U0080					      org	$80	; origin set at base of ram 
     32 U0080
     33 U0080							; define variables
     34 U0080		       00	   pf_segment ds	1
     35 U0081		       00	   pf_segindex ds	1
     36 U0082		       00 00	   b_y	      ds	2	; ball y pos
     37 U0084		       00 00	   b_bearing  ds	2	; (0-15) 16 angles 22.5 deg apart
     38 U0086		       00 00	   b_bearing_old ds	2	; holds the original bearing (direction) of the ball before bounce
     39 U0088		       00 00	   collision_count ds	2	; collision count
     40 U008a		       00	   pf_count   ds	1	; playfield index
     41 U008b		       00	   p_collision ds	1	; current players collision register value
     42 U008c		       00	   r_seed     ds	1	; random seed
     43 U008d		       00 00	   snd_on     ds	2	; 1 byte per audio channel - greater than 0 if sound is playing
     44 U008f
     45  10000 ????				       seg	main	; start of main segment
     46  f000					      org	$F000
     47  f000
     48  f000				   reset
      0  f000					      CLEAN_START		; ouput: all ram/registers 0
      1  f000		       78		      sei
      2  f001		       d8		      cld
      3  f002
      4  f002				  -	      IFNCONST	NO_ILLEGAL_OPCODES
      5  f002				  -	      lxa	#0
      6  f002					      ELSE
      7  f002		       a2 00		      ldx	#0
      8  f004		       8a		      txa
      9  f005					      ENDIF
     10  f005		       a8		      tay
     11  f006		       ca	   .CLEAR_STACK dex
     12  f007		       9a		      txs
     13  f008		       48		      pha
     14  f009		       d0 fb		      bne	.CLEAR_STACK
     15  f00b
     50  f00b
     51  f00b							; generate a random seed from the interval timer
     52  f00b		       ad 84 02 	      lda	INTIM	; unknown value to use as an initial random seed
     53  f00e		       85 8c		      sta	r_seed
     54  f010
     55  f010							; set area values
     56  f010		       a9 15		      lda	#%00010101	; playfield to reflect (default behavior, not nessesary)
     57  f012		       85 0a		      sta	CTRLPF
     58  f014		       85 25		      sta	VDELP0	; draw player 0 when player 1 is drawm
     59  f016
     60  f016				   soft_reset
     61  f016
     62  f016		       a2 00		      ldx	#0	; p0
     63  f018		       a9 50		      lda	#80	; p0 horizontal position
     64  f01a		       20 1e f1 	      jsr	init_object	; p0 starting position
     65  f01d
     66  f01d		       e8		      inx		; p1
     67  f01e		       a9 28		      lda	#40	; p1 horizontal position
     68  f020		       20 1e f1 	      jsr	init_object	; p1 starting position
     69  f023
     70  f023							; lock the graphic object positions
     71  f023		       85 02		      sta	WSYNC
     72  f025		       85 2a		      sta	HMOVE	; strobe horizontal move to set fine positions  
     73  f027
     74  f027		       a9 00		      lda	#0	; start on the first index of the current playfield segment to draw
     75  f029		       85 81		      sta	pf_segindex
     76  f02b
     77  f02b							; set the game color scheme based on selected region	    
     78  f02b		       a9 46		      lda	#RED	; defined in build.h
     79  f02d		       85 08		      sta	COLUPF
     80  f02f
     81  f02f		       a9 1e		      lda	#YELLOW	; defined in build.h
     82  f031		       85 06		      sta	COLUP0
     83  f033
     84  f033		       a9 a6		      lda	#BLUE	; defined in build.h
     85  f035		       85 07		      sta	COLUP1
     86  f037
     87  f037				   NextFrame
      0  f037					      VERTICAL_SYNC		; output: a = 0; 3 scanlines
      1  f037		       a9 0e		      lda	#%1110
      2  f039		       85 02	   .VSLP1     sta	WSYNC
      3  f03b		       85 00		      sta	VSYNC
      4  f03d		       4a		      lsr
      5  f03e		       d0 f9		      bne	.VSLP1
     89  f040
     90  f040				   VerticalBlank
     91  f040		       a2 2b		      ldx	#VBLANKTIME	; defined/precalculated in build.h
     92  f042		       8e 96 02 	      stx	TIM64T	; set 64-clock for 43 intervals. 
     93  f045
     94  f045							; process the sound channels to turn off volume when counter runs out
     95  f045		       20 5c f1 	      jsr	snd_process
     96  f048
     97  f048							; we're checking the collision between p0+pf, p1+pf, and p1+p2
     98  f048		       a2 01		      ldx	#1	; start with p1 and work down to p0
     99  f04a				   CollisionNextObject
    100  f04a
    101  f04a							; collision detection
    102  f04a		       b5 02		      lda	CXP0FB,x	; object collision with playfield?
    103  f04c		       05 07		      ora	CXPPMM	; bounce on p0+p1 collision - no reason to do for both p0 and p1 but it's a convience place
    104  f04e		       85 8b		      sta	p_collision
    105  f050		       a9 80		      lda	#%10000000
    106  f052		       25 8b		      and	p_collision
    107  f054		       d0 07		      bne	collision
    108  f056
    109  f056		       a9 00		      lda	#0	; no collision, set collision count to 0
    110  f058		       95 88		      sta	collision_count,x
    111  f05a		       4c 93 f0 	      jmp	no_collision	; bypass collision handling
    112  f05d
    113  f05d							; when a collision occures we try to reflect to a vertical bearing. If on the next frame we're still
    114  f05d							; registering a collision then we try a horizontal bearing. If it's STILL registering a collision 
    115  f05d							; then we reflect it back 180 degrees from the original pre-bounce bearing.
    116  f05d
    117  f05d				   collision
    118  f05d							; a collision occured
    119  f05d		       b5 88		      lda	collision_count,x	; how many times has a collision occured consecutively
    120  f05f		       d0 1a		      bne	col_on	; branch if collisions are already ongoing
    121  f061
    122  f061		       8a		      txa
    123  f062		       a8		      tay		; sound parameter index from sndbank_*
    124  f063		       20 47 f1 	      jsr	snd_play	; call the subroutine to load the audio registers, use the p0/p1 value in x for channel
    125  f066
    126  f066		       b5 84		      lda	b_bearing,x	; get the current bearing
    127  f068		       95 86		      sta	b_bearing_old,x	; store current b_bearing
    128  f06a		       49 ff		      eor	#$FF	; reverse our bearings 
    129  f06c		       95 84		      sta	b_bearing,x
    130  f06e		       f6 84		      inc	b_bearing,x	; additive reverse
    131  f070		       b5 84		      lda	b_bearing,x
    132  f072		       29 03		      and	#$03	; is bearing N,S,E,W?
    133  f074		       d0 02		      bne	col_no_adj
    134  f076		       f6 84		      inc	b_bearing,x	; increment bearing by one offset to prevent continuous reflection
    135  f078
    136  f078				   col_no_adj
    137  f078		       4c 91 f0 	      jmp	collision_done
    138  f07b
    139  f07b		       c9 01	   col_on     cmp	#$01	; check collision_count
    140  f07d		       f0 0b		      beq	reverse_bearing	; first collision in series
    141  f07f		       c9 03		      cmp	#$03	; check collision_count
    142  f081		       90 0e		      bcc	collision_done	; second/third collision in series
    143  f083		       d0 0c		      bne	collision_done	; more than three collisions in series
    144  f085		       b5 86		      lda	b_bearing_old,x	; retrieve pre-bounce bearing
    145  f087		       4c 8c f0 	      jmp	reverse_org_bearing	; reverse bearing it 180 degrees
    146  f08a
    147  f08a				   reverse_bearing		; reverse altered bearing
    148  f08a		       b5 84		      lda	b_bearing,x
    149  f08c				   reverse_org_bearing		; reverse original bearing
    150  f08c		       18		      clc		; clear carry so it's not included in add on next instruction
    151  f08d		       69 08		      adc	#$08	; reverse bearing by 180 degrees
    152  f08f		       95 84		      sta	b_bearing,x
    153  f091
    154  f091				   collision_done
    155  f091		       f6 88		      inc	collision_count,x	; increment the number of consecutive collisions
    156  f093				   no_collision
    157  f093
    158  f093							; move the ball
    159  f093		       b5 84		      lda	b_bearing,x
    160  f095		       29 0f		      and	#$0F	; strip the high nibble
    161  f097		       a8		      tay
    162  f098		       b9 0a f2 	      lda	bearing_offsets,y	; load the x/y offsets based on the current bearing
    163  f09b		       95 20		      sta	HMP0,x	; horizontally move the current player object
    164  f09d							; update the balls horizontal motion register which will only
    165  f09d							; use the high nibble where the x offset is stored.
    166  f09d		       29 0f		      and	#$0F	; strip out the high nibble which leaves only the y offset
    167  f09f		       38		      sec		; set the carry flag
    168  f0a0		       e9 08		      sbc	#$08	; subtract 8 for 4bit 2's completment +/-
    169  f0a2		       18		      clc		; clear carry flag so it's not used in the following add
    170  f0a3		       75 82		      adc	b_y,x	; add y offset to current y position
    171  f0a5		       95 82		      sta	b_y,x	; store the new y position
    172  f0a7
    173  f0a7		       ca		      dex		; done processing collision with current object, move on to the next p1->p0
    174  f0a8		       10 a0		      bpl	CollisionNextObject	; when result is positive move on to p0, when negative pass through loop 
    175  f0aa
    176  f0aa		       a0 ff		      ldy	#255	; prime for first playfield segment (kernel starts with a inc pf_segment which brings it to 0 to start)
    177  f0ac		       84 80		      sty	pf_segment
    178  f0ae		       a2 60		      ldx	#VOUTLINES	; defined in build.h
    179  f0b0		       86 8a		      stx	pf_count	; this is a 2 line kernel (2lk) so count is 1/2 pf height
    180  f0b2
    181  f0b2		       85 02		      sta	WSYNC
    182  f0b4							;--------------------------------------	
    183  f0b4
    184  f0b4		       85 2a		      sta	HMOVE	; set fine horizontal positioning
    185  f0b6		       85 2c		      sta	CXCLR	; clear all the collision registers
    186  f0b8
    187  f0b8				   checktimer
    188  f0b8		       ad 84 02 	      lda	INTIM	; time remaining (or past)
    189  f0bb		       d0 fb		      bne	checktimer	; burn remaining cycles
    190  f0bd
    191  f0bd		       a9 00		      lda	#0	; D1 to 0 to end VBLANK
    192  f0bf		       85 02		      sta	WSYNC
    193  f0c1							;--------------------------------------	
    194  f0c1		       85 01		      sta	VBLANK	; set vertical blank off
    195  f0c3
    196  f0c3				   vout
    197  f0c3		       46 81		      lsr	pf_segindex	; 5  5 - defined in build.h (how many scanlines used for each segment. different for NTSC, PAL)
    198  f0c5		       d0 06		      bne	skipx	; 3  8 
    199  f0c7		       e6 80		      inc	pf_segment	; 5 13
    200  f0c9		       a9 0f		      lda	#PFSEGHEIGHT	; 2 15      
    201  f0cb		       85 81		      sta	pf_segindex	; 3 18
    202  f0cd
    203  f0cd				   skipx
    204  f0cd		       a4 80		      ldy	pf_segment	; 2 20
    205  f0cf		       b9 1c f2 	      lda	PF0_data_atari,y	; 4 24 
    206  f0d2		       85 02		      sta	WSYNC	; 3 27 	  
    207  f0d4							;--------------------------------------	 
    208  f0d4
    209  f0d4							; draw playfield
    210  f0d4		       85 0d		      sta	PF0	; 3 29
    211  f0d6		       b9 34 f2 	      lda	PF1_data_atari,y	; 4 34
    212  f0d9		       85 0e		      sta	PF1	; 3 37
    213  f0db		       b9 4c f2 	      lda	PF2_data_atari,y	; 4 41
    214  f0de		       85 0f		      sta	PF2	; 3 44
    215  f0e0		       a9 3c		      lda	#ORANGE	; 2 46 - defined in build.h 
    216  f0e2		       85 09		      sta	COLUBK	; 3 49
    217  f0e4
    218  f0e4		       a0 01		      ldy	#1	; 2 51
    219  f0e6				   drawballs
    220  f0e6		       a2 00		      ldx	#0	; 2 53
    221  f0e8		       b9 82 00 	      lda	b_y,y	; 4 57 - load ball y pos
    222  f0eb		       c5 8a		      cmp	pf_count	; 2 59 - compare y pos to playfield counter
    223  f0ed		       d0 03		      bne	noball	; 3 62 - if it's not the same then continue with blank player graphic
    224  f0ef		       be 00 f2 	      ldx	p_graphic,y	; 4 66 - ball y pos and playfield counter are same so set player graphic
    225  f0f2				   noball
    226  f0f2		       96 1b		      stx	GRP0,y	; 4 70 - enable current player graphic
    227  f0f4
    228  f0f4		       88		      dey		; 2 72 - move on to next player graphic
    229  f0f5		       10 ef		      bpl	drawballs	; 2 74 - if result positive then draw next graphic which would add 75 additional cycles to the count
    230  f0f7
    231  f0f7		       85 02		      sta	WSYNC	; 3 149
    232  f0f9							;--------------------------------------
    233  f0f9
    234  f0f9		       c6 8a		      dec	pf_count	; 5 154
    235  f0fb		       d0 c6		      bne	vout	; 3 157
    236  f0fd
    237  f0fd							; end of VOUT
    238  f0fd		       85 02		      sta	WSYNC	; end kernel with a clean scan line
    239  f0ff							;--------------------------------------
    240  f0ff
    241  f0ff		       a9 00		      lda	#$0
    242  f101		       85 0d		      sta	PF0
    243  f103		       85 0e		      sta	PF1
    244  f105		       85 0f		      sta	PF2
    245  f107		       85 09		      sta	COLUBK
    246  f109		       85 1b		      sta	GRP0
    247  f10b		       85 1c		      sta	GRP1
    248  f10d		       a9 02		      lda	#$2	; set D1 = 1 to initiate VBLANK
    249  f10f		       85 01		      sta	VBLANK	; turn off the beam
    250  f111
    251  f111							; ---- overscan (30 scanlines)
    252  f111		       a2 23		      ldx	#OVERSCANTIME	; defined in build.h - We'll round down, and clean up the remaining cycles with a WSYNC
    253  f113		       8e 96 02 	      stx	TIM64T	; Set a count of 35 with 64-clock interval
    254  f116
    255  f116							; overscan remainder timer -----------
    256  f116				   overscan_timer
    257  f116		       ae 84 02 	      ldx	INTIM
    258  f119		       d0 fb		      bne	overscan_timer
    259  f11b		       4c 37 f0 	      jmp	NextFrame	; jump back up to start the next frame
    260  f11e
    261  f11e				   init_object
    262  f11e							; a = x position, x = object		 
    263  f11e		       95 82		      sta	b_y,x	; y pos
    264  f120		       20 35 f1 	      jsr	PositionX	; a = x pos, x = object (index from P0 object address)
    265  f123
    266  f123							; 'randomly' select an initial bearing (direction)
    267  f123		       20 2b f1 	      jsr	galois_lfsr_random	; no need to store the seed for this one
    268  f126		       29 0f		      and	#$0F	; limit the value to 0-15
    269  f128		       95 84		      sta	b_bearing,x
    270  f12a
    271  f12a		       60		      rts
    272  f12b
    273  f12b
    274  f12b							; Galois 8-bit Linear Feedback Shift Registers
    275  f12b							; https://samiam.org/blog/20130617.html
    276  f12b				   galois_lfsr_random
    277  f12b		       a5 8c		      lda	r_seed	; keep calling funtion to for better entropy
    278  f12d		       4a		      lsr		; shift right
    279  f12e		       90 02		      bcc	noeor0	; if carry 1, then exclusive OR the bits
    280  f130		       49 d4		      eor	#$D4	; d4 tap (11010100)
    281  f132		       85 8c	   noeor0     sta	r_seed
    282  f134		       60		      rts
    283  f135
    284  f135							; -----------------------------------------------------------------------------
    285  f135							; PositionX
    286  f135							; A - Horizontal position of the object
    287  f135							; X - Object to position
    288  f135							;   0 - Player 0
    289  f135							;   1 - Player 1
    290  f135							;   2 - Missile 0
    291  f135							;   3 - Missile 1
    292  f135							;   4 - Ball
    293  f135							; -----------------------------------------------------------------------------
    294  f135
    295  f135				   PositionX
    296  f135		       38		      sec		;  2 +2 - set the carry flag
    297  f136		       85 02		      sta	WSYNC	;  3 +5 - start a new line
    298  f138				   DivideLoop
    299  f138		       e9 0f		      sbc	#15	;  2  2 - subtract 15
    300  f13a		       b0 fc		      bcs	DivideLoop	;  2  4 - branch until negative
    301  f13c		       49 07		      eor	#7	;  2  6 - calculate fine offset
    302  f13e		       0a		      asl		;  2  8 - shift left
    303  f13f		       0a		      asl		;  2 10
    304  f140		       0a		      asl		;  2 12
    305  f141		       0a		      asl		;  2 14
    306  f142		       95 20		      sta	HMP0,x	;  5 19 - set fine offset
    307  f144		       95 10		      sta	RESP0,x	;  4 23 - set coarse position
    308  f146		       60		      rts		;  6 29 - return
    309  f147
    310  f147							; cues a sound to play. sets audio registers based on table lookup sndbank.
    311  f147							; parameters: x = channel (0|1), y = sound to play
    312  f147				   snd_play
    313  f147		       b9 02 f2 	      lda	sndbank_type,y
    314  f14a		       95 15		      sta	AUDC0,x	; audio control   
    315  f14c		       b9 04 f2 	      lda	sndbank_vol,y
    316  f14f		       95 19		      sta	AUDV0,x	; audio volume
    317  f151		       b9 06 f2 	      lda	sndbank_pitch,y
    318  f154		       95 17		      sta	AUDF0,x	; audio frequence
    319  f156		       b9 08 f2 	      lda	sndbank_len,y
    320  f159		       95 8d		      sta	snd_on,x	; len of audio in frames (>0 = sound on)
    321  f15b		       60		      rts
    322  f15c
    323  f15c							; process sound channels to turn off volume when sound length counter runs out
    324  f15c				   snd_process
    325  f15c		       a2 01		      ldx	#1	; channel to process, start with channel 1
    326  f15e				   snd_ch
    327  f15e		       b5 8d		      lda	snd_on,x	; get sound length counter for this channel
    328  f160		       f0 08		      beq	snd_done	; are we playing a sound? a>1 
    329  f162		       d6 8d		      dec	snd_on,x	; yes, decrese the sound length counter for this channel
    330  f164		       d0 04		      bne	snd_cont	; did we reach the end of the sound length?
    331  f166		       a9 00		      lda	#0	; yes
    332  f168		       95 19		      sta	AUDV0,x	; turn off the volume for this channel 
    333  f16a				   snd_done
    334  f16a				   snd_cont
    335  f16a		       ca		      dex		; do it again for channel 0
    336  f16b		       f0 f1		      beq	snd_ch
    337  f16d		       60		      rts
    338  f16e
    339  f200		       00 00 00 00*	      align	$100	; align data
    340  f200
    341  f200				   p_graphic
    342  f200		       03		      .byte.b	#%00000011	; p0
    343  f201		       03		      .byte.b	#%00000011	; p1
    344  f202
    345  f202							; define sounds, p0, p1
    346  f202				   sndbank_type
    347  f202		       0c 0c		      .byte.b	$0C, $0C
    348  f204				   sndbank_vol
    349  f204		       02 02		      .byte.b	$02, $02
    350  f206				   sndbank_pitch
    351  f206		       0d 0f		      .byte.b	$0D, $0F
    352  f208				   sndbank_len
    353  f208		       01 01		      .byte.b	$01, $01
    354  f20a
    355  f20a							;index  x-move  y-move  deg	 direction  
    356  f20a				   bearing_offsets		;------------------------------------------												
    357  f20a		       e0		      .byte.b	#%11100000	; 0	 -2	  0	 90.0	 right
    358  f20b		       e7		      .byte.b	#%11100111	; 1	 -2	 -2	 67.5
    359  f20c		       e6		      .byte.b	#%11100110	; 2	 -2	 -4	 45.0
    360  f20d		       f6		      .byte.b	#%11110110	; 3	 -1	 -4	 22.5
    361  f20e		       06		      .byte.b	#%00000110	; 4	  0	 -4	 0/360	 up
    362  f20f		       16		      .byte.b	#%00010110	; 5	 +1	 -4	 337.5
    363  f210		       26		      .byte.b	#%00100110	; 6	 +2	 -4	 315.0
    364  f211		       27		      .byte.b	#%00100111	; 7	 +2	 -2	 292.5	
    365  f212		       28		      .byte.b	#%00101000	; 8	 +2	  0	 270.0	 left
    366  f213		       29		      .byte.b	#%00101001	; 9	 +2	 +2	 247.5
    367  f214		       2a		      .byte.b	#%00101010	; 10	 +2	 +4	 225.0
    368  f215		       1a		      .byte.b	#%00011010	; 11	 +1	 +4	 202.5
    369  f216		       0a		      .byte.b	#%00001010	; 12	  0	 +4	 180.0	 down
    370  f217		       fa		      .byte.b	#%11111010	; 13	 -1	 +4	 157.5
    371  f218		       ea		      .byte.b	#%11101010	; 14	 -2	 +4	 135.0
    372  f219		       e9		      .byte.b	#%11101001	; 15	 -2	 +2	 112.5;
    373  f21a
------- FILE playfields/pf_atari.asm LEVEL 2 PASS 2
      0  f21a					      INCLUDE	"playfields/pf_atari.asm"
      1  f21a				   PF_col_atari
      2  f21a		       46		      .byte.b	#$46	; foreground
      3  f21b		       00		      .byte.b	#$00	; background
      4  f21c
      5  f21c				   PF0_data_atari
      6  f21c		       f0		      .byte.b	#%11110000	;<- first
      7  f21d		       10		      .byte.b	#%00010000
      8  f21e		       10		      .byte.b	#%00010000
      9  f21f		       10		      .byte.b	#%00010000
     10  f220		       10		      .byte.b	#%00010000
     11  f221		       10		      .byte.b	#%00010000
     12  f222		       10		      .byte.b	#%00010000
     13  f223		       10		      .byte.b	#%00010000
     14  f224		       10		      .byte.b	#%00010000
     15  f225		       10		      .byte.b	#%00010000
     16  f226		       10		      .byte.b	#%00010000
     17  f227		       10		      .byte.b	#%00010000
     18  f228		       10		      .byte.b	#%00010000
     19  f229		       10		      .byte.b	#%00010000
     20  f22a		       10		      .byte.b	#%00010000
     21  f22b		       10		      .byte.b	#%00010000
     22  f22c		       10		      .byte.b	#%00010000
     23  f22d		       10		      .byte.b	#%00010000
     24  f22e		       10		      .byte.b	#%00010000
     25  f22f		       10		      .byte.b	#%00010000
     26  f230		       10		      .byte.b	#%00010000
     27  f231		       10		      .byte.b	#%00010000
     28  f232		       10		      .byte.b	#%00010000
     29  f233		       f0		      .byte.b	#%11110000	;<- last
     30  f234
     31  f234				   PF1_data_atari
     32  f234		       ff		      .byte.b	#%11111111	;<- first
     33  f235		       00		      .byte.b	#%00000000
     34  f236		       00		      .byte.b	#%00000000
     35  f237		       00		      .byte.b	#%00000000
     36  f238		       00		      .byte.b	#%00000000
     37  f239		       00		      .byte.b	#%00000000
     38  f23a		       00		      .byte.b	#%00000000
     39  f23b		       00		      .byte.b	#%00000000
     40  f23c		       00		      .byte.b	#%00000000
     41  f23d		       00		      .byte.b	#%00000000
     42  f23e		       00		      .byte.b	#%00000000
     43  f23f		       00		      .byte.b	#%00000000
     44  f240		       00		      .byte.b	#%00000000
     45  f241		       00		      .byte.b	#%00000000
     46  f242		       00		      .byte.b	#%00000000
     47  f243		       00		      .byte.b	#%00000000
     48  f244		       00		      .byte.b	#%00000000
     49  f245		       00		      .byte.b	#%00000000
     50  f246		       03		      .byte.b	#%00000011
     51  f247		       03		      .byte.b	#%00000011
     52  f248		       00		      .byte.b	#%00000000
     53  f249		       00		      .byte.b	#%00000000
     54  f24a		       00		      .byte.b	#%00000000
     55  f24b		       ff		      .byte.b	#%11111111	;<- last
     56  f24c
     57  f24c				   PF2_data_atari
     58  f24c		       ff		      .byte.b	#%11111111	;<- first
     59  f24d		       00		      .byte.b	#%00000000
     60  f24e		       00		      .byte.b	#%00000000
     61  f24f		       b0		      .byte.b	#%10110000
     62  f250		       b0		      .byte.b	#%10110000
     63  f251		       b0		      .byte.b	#%10110000
     64  f252		       b0		      .byte.b	#%10110000
     65  f253		       b0		      .byte.b	#%10110000
     66  f254		       b0		      .byte.b	#%10110000
     67  f255		       b0		      .byte.b	#%10110000
     68  f256		       b0		      .byte.b	#%10110000
     69  f257		       98		      .byte.b	#%10011000
     70  f258		       98		      .byte.b	#%10011000
     71  f259		       98		      .byte.b	#%10011000
     72  f25a		       9c		      .byte.b	#%10011100
     73  f25b		       8c		      .byte.b	#%10001100
     74  f25c		       8e		      .byte.b	#%10001110
     75  f25d		       87		      .byte.b	#%10000111
     76  f25e		       83		      .byte.b	#%10000011
     77  f25f		       81		      .byte.b	#%10000001
     78  f260		       00		      .byte.b	#%00000000
     79  f261		       00		      .byte.b	#%00000000
     80  f262		       00		      .byte.b	#%00000000
     81  f263		       ff		      .byte.b	#%11111111	;<- last
------- FILE D:\src\u\s\emu\tests\bins\8blit\8blit-s03e04-Regions-before-2.asm
    375  f264
    376  fffa					      org	$FFFA
    377  fffa
    378  fffa		       00 f0		      .word.w	reset	; NMI	($FFFA)
    379  fffc		       00 f0		      .word.w	reset	; RESET ($FFFC)
    380  fffe		       00 f0		      .word.w	reset	; IRQ ($FFFE)
