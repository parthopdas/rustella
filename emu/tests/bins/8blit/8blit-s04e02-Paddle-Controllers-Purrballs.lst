------- FILE D:\src\u\s\emu\tests\bins\8blit\8blit-s04e02-Paddle-Controllers-Purrballs.asm LEVEL 1 PASS 2
      1  10000 ????						; Purrballs 0.3
      2  10000 ????						; all rights reserved.
      3  10000 ????
      4  10000 ????						; Implementing a scoreboard in a game context
      5  10000 ????
      6  10000 ????						; This Episode on Youtube - https://youtu.be/CuFHfAzsTw0
      7  10000 ????
      8  10000 ????						; Become a Patron - https://patreon.com/8blit
      9  10000 ????						; 8blit Merch - https://8blit.myspreadshop.com/
     10  10000 ????						; Subscribe to 8Blit - https://www.youtube.com/8blit?sub_confirmation=1
     11  10000 ????						; Follow on Facebook - https://www.facebook.com/8Blit
     12  10000 ????						; Follow on Instagram - https://www.instagram.com/8blit
     13  10000 ????						; Visit the Website - https://www.8blit.com 
     14  10000 ????
     15  10000 ????						; Email - 8blit0@gmail.com
     16  10000 ????
     17  10000 ????				       processor	6502
     18  10000 ????
------- FILE vcs.h LEVEL 2 PASS 2
      0  10000 ????				       include	"vcs.h"
      1  10000 ????						; VCS.H
      2  10000 ????						; Version 1.06, 06/SEP/2020
      3  10000 ????
      4  10000 ????		00 6a	    VERSION_VCS =	106
      5  10000 ????
      6  10000 ????						; THIS IS *THE* "STANDARD" VCS.H
      7  10000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8  10000 ????						; The latest version can be found at https://dasm-assembler.github.io/
      9  10000 ????						;
     10  10000 ????						; This file defines hardware registers and memory mapping for the
     11  10000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     12  10000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     13  10000 ????						; available at at https://dasm-assembler.github.io/
     14  10000 ????						;
     15  10000 ????						; Many thanks to the people who have contributed. If you find an issue with the
     16  10000 ????						; contents, or would like ot add something, please report as an issue at...
     17  10000 ????						; https://github.com/dasm-assembler/dasm/issues
     18  10000 ????
     19  10000 ????						;
     20  10000 ????						; Latest Revisions...
     21  10000 ????						; 1.06  05/SEP/2020	 Modified header/license and links to new versions
     22  10000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     23  10000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     24  10000 ????						;			    This will allow conditional code to verify VCS.H being
     25  10000 ????						;			    used for code assembly.
     26  10000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     27  10000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     28  10000 ????						;			 mirrored reading/writing differences.	This is more a 
     29  10000 ????						;			 readability issue, and binary compatibility with disassembled
     30  10000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     31  10000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     32  10000 ????						;			 which was broken by the use of segments in this file, as
     33  10000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     34  10000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     35  10000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     36  10000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     37  10000 ????						;						   it is safe to leave it undefined, and the base address will
     38  10000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     39  10000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     40  10000 ????						;			  - register definitions are now generated through assignment
     41  10000 ????						;			    in uninitialised segments.	This allows a changeable base
     42  10000 ????						;			    address architecture.
     43  10000 ????						; 1.0	22/MAR/2003		Initial release
     44  10000 ????
     45  10000 ????
     46  10000 ????						;-------------------------------------------------------------------------------
     47  10000 ????
     48  10000 ????						; TIA_BASE_ADDRESS
     49  10000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     50  10000 ????						; Normally 0, the base address should (externally, before including this file)
     51  10000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     52  10000 ????						; The reason is that this bankswitching scheme treats any access to locations
     53  10000 ????						; < $40 as a bankswitch.
     54  10000 ????
     55  10000 ????			   -	       IFNCONST	TIA_BASE_ADDRESS
     56  10000 ????			   -TIA_BASE_ADDRESS =	0
     57  10000 ????				       ENDIF
     58  10000 ????
     59  10000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     60  10000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     61  10000 ????						; *OR* by declaring the label before including this file, eg:
     62  10000 ????						; TIA_BASE_ADDRESS = $40
     63  10000 ????						;   include "vcs.h"
     64  10000 ????
     65  10000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     66  10000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     67  10000 ????						; for the mirrored ROM hardware registers.
     68  10000 ????
     69  10000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     70  10000 ????						; using the -D command-line switch, as required.  If the addresses are not defined, 
     71  10000 ????						; they defaut to the TIA_BASE_ADDRESS.
     72  10000 ????
     73  10000 ????			   -	       IFNCONST	TIA_BASE_READ_ADDRESS
     74  10000 ????			   -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     75  10000 ????				       ENDIF
     76  10000 ????
     77  10000 ????			   -	       IFNCONST	TIA_BASE_WRITE_ADDRESS
     78  10000 ????			   -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     79  10000 ????				       ENDIF
     80  10000 ????
     81  10000 ????						;-------------------------------------------------------------------------------
     82  10000 ????
     83 U002d ????				      SEG.U	TIA_REGISTERS_WRITE
     84 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     85 U0000
     86 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     87 U0000
     88 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     89 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     90 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     91 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     92 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     93 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     94 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     95 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     96 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     97 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     98 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     99 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    100 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    101 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    102 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    103 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    104 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    105 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    106 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    107 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    108 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    109 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    110 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    111 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    112 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    113 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    114 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    115 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    116 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    117 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    118 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    119 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    120 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    121 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    122 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    123 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    124 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    125 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    126 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    127 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    128 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    129 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    130 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    131 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    132 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    133 U002d
    134 U002d							;-------------------------------------------------------------------------------
    135 U002d
    136 U000e ????				      SEG.U	TIA_REGISTERS_READ
    137 U0000					      ORG	TIA_BASE_READ_ADDRESS
    138 U0000
    139 U0000							;											bit 7	 bit 6
    140 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    141 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    142 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    143 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    144 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    145 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    146 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    147 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    148 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    149 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    150 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    151 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    152 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    153 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    154 U000e
    155 U000e							;-------------------------------------------------------------------------------
    156 U000e
    157 U0298 ????				      SEG.U	RIOT
    158 U0280					      ORG	$280
    159 U0280
    160 U0280							; RIOT MEMORY MAP
    161 U0280
    162 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    163 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    164 U0281
    165 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    166 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    167 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    168 U0284		       00	   INTIM      ds	1	; $284		Timer output
    169 U0285
    170 U0285		       00	   TIMINT     ds	1	; $285
    171 U0286
    172 U0286							; Unused/undefined registers ($285-$294)
    173 U0286
    174 U0286		       00		      ds	1	; $286
    175 U0287		       00		      ds	1	; $287
    176 U0288		       00		      ds	1	; $288
    177 U0289		       00		      ds	1	; $289
    178 U028a		       00		      ds	1	; $28A
    179 U028b		       00		      ds	1	; $28B
    180 U028c		       00		      ds	1	; $28C
    181 U028d		       00		      ds	1	; $28D
    182 U028e		       00		      ds	1	; $28E
    183 U028f		       00		      ds	1	; $28F
    184 U0290		       00		      ds	1	; $290
    185 U0291		       00		      ds	1	; $291
    186 U0292		       00		      ds	1	; $292
    187 U0293		       00		      ds	1	; $293
    188 U0294
    189 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    190 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    191 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    192 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    193 U0298
    194 U0298							;-------------------------------------------------------------------------------
    195 U0298							; The following required for back-compatibility with code which does not use
    196 U0298							; segments.
    197 U0298
    198  0000 ????				      SEG
    199  0000 ????
    200  0000 ????						; EOF
------- FILE D:\src\u\s\emu\tests\bins\8blit\8blit-s04e02-Paddle-Controllers-Purrballs.asm
------- FILE macro.h LEVEL 2 PASS 2
      0  0000 ????				      include	"macro.h"
      1  0000 ????						; MACRO.H
      2  0000 ????						; Version 1.09, 05/SEP/2020
      3  0000 ????
      4  0000 ????	       00 6d	   VERSION_MACRO =	109
      5  0000 ????
      6  0000 ????						;
      7  0000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8  0000 ????						; The latest version can be found at https://dasm-assembler.github.io/
      9  0000 ????						;
     10  0000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     11  0000 ????						; It is distributed as a companion machine-specific support package
     12  0000 ????						; for the DASM compiler.
     13  0000 ????						;
     14  0000 ????						; Many thanks to the people who have contributed. If you find an issue with the
     15  0000 ????						; contents, or would like ot add something, please report as an issue at...
     16  0000 ????						; https://github.com/dasm-assembler/dasm/issues
     17  0000 ????
     18  0000 ????
     19  0000 ????						; Latest Revisions...
     20  0000 ????						; 1.09  05/SEP/2020	 - updated license/links
     21  0000 ????
     22  0000 ????						; 1.08  13/JUL/2020	 - added use of LXA to CLEAN_START
     23  0000 ????						; 1.07  19/JAN/2020	 - correction to comment VERTICAL_SYNC
     24  0000 ????						; 1.06  03/SEP/2004	 - nice revision of VERTICAL_SYNC (Edwin Blink)
     25  0000 ????						; 1.05  14/NOV/2003	 - Added VERSION_MACRO equate (which will reflect 100x version #)
     26  0000 ????						;			   This will allow conditional code to verify MACRO.H being
     27  0000 ????						;			   used for code assembly.
     28  0000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     29  0000 ????						;
     30  0000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     31  0000 ????						;
     32  0000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     33  0000 ????						;			   (standardised macro for vertical synch code)
     34  0000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added. 
     35  0000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     36  0000 ????						; 1.0	22/MAR/2003		Initial release
     37  0000 ????
     38  0000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage, 
     39  0000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     40  0000 ????						;   If you do not allow illegal opcode usage, you must include this file 
     41  0000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     42  0000 ????						;   registers and require them to be defined first).
     43  0000 ????
     44  0000 ????						; Available macros...
     45  0000 ????						;   SLEEP n		 - sleep for n cycles
     46  0000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     47  0000 ????						;   CLEAN_START	 - set machine to known state on startup
     48  0000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     49  0000 ????
     50  0000 ????						;-------------------------------------------------------------------------------
     51  0000 ????						; SLEEP duration
     52  0000 ????						; Original author: Thomas Jentzsch
     53  0000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     54  0000 ????						; useful for code where precise timing is required.
     55  0000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     56  0000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     57  0000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     58  0000 ????
     59  0000 ????				      MAC	sleep
     60  0000 ????			   .CYCLES    SET	{1}
     61  0000 ????
     62  0000 ????				      IF	.CYCLES < 2
     63  0000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     64  0000 ????				      ERR
     65  0000 ????				      ENDIF
     66  0000 ????
     67  0000 ????				      IF	.CYCLES & 1
     68  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     69  0000 ????				      nop	0
     70  0000 ????				      ELSE
     71  0000 ????				      bit	VSYNC
     72  0000 ????				      ENDIF
     73  0000 ????			   .CYCLES    SET	.CYCLES - 3
     74  0000 ????				      ENDIF
     75  0000 ????
     76  0000 ????				      REPEAT	.CYCLES / 2
     77  0000 ????				      nop
     78  0000 ????				      REPEND
     79  0000 ????				      ENDM		;usage: SLEEP n (n>1)
     80  0000 ????
     81  0000 ????						;-------------------------------------------------------------------------------
     82  0000 ????						; VERTICAL_SYNC
     83  0000 ????						; revised version by Edwin Blink -- saves bytes!
     84  0000 ????						; Inserts the code required for a proper 3 scanline vertical sync sequence
     85  0000 ????						; Note: Alters the accumulator
     86  0000 ????
     87  0000 ????						; OUT: A = 0
     88  0000 ????
     89  0000 ????				      MAC	vertical_sync
     90  0000 ????				      lda	#%1110	; each '1' bits generate a VSYNC ON line (bits 1..3)
     91  0000 ????			   .VSLP1     sta	WSYNC	; 1st '0' bit resets Vsync, 2nd '0' bit exit loop
     92  0000 ????				      sta	VSYNC
     93  0000 ????				      lsr
     94  0000 ????				      bne	.VSLP1	; branch until VYSNC has been reset
     95  0000 ????				      ENDM
     96  0000 ????
     97  0000 ????						;-------------------------------------------------------------------------------
     98  0000 ????						; CLEAN_START
     99  0000 ????						; Original author: Andrew Davie
    100  0000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
    101  0000 ????						; Sets stack pointer to $FF, and all registers to 0
    102  0000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    103  0000 ????						; Use as very first section of code on boot (ie: at reset)
    104  0000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    105  0000 ????
    106  0000 ????				      MAC	clean_start
    107  0000 ????				      sei
    108  0000 ????				      cld
    109  0000 ????
    110  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
    111  0000 ????				      lxa	#0
    112  0000 ????				      ELSE
    113  0000 ????				      ldx	#0
    114  0000 ????				      txa
    115  0000 ????				      ENDIF
    116  0000 ????				      tay
    117  0000 ????			   .CLEAR_STACK dex
    118  0000 ????				      txs
    119  0000 ????				      pha
    120  0000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    121  0000 ????
    122  0000 ????				      ENDM
    123  0000 ????
    124  0000 ????						;-------------------------------------------------------
    125  0000 ????						; SET_POINTER
    126  0000 ????						; Original author: Manuel Rotschkar
    127  0000 ????						;
    128  0000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    129  0000 ????						;
    130  0000 ????						; Usage: SET_POINTER pointer, address
    131  0000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    132  0000 ????						;
    133  0000 ????						; Note: Alters the accumulator, NZ flags
    134  0000 ????						; IN 1: 2 byte RAM location reserved for pointer
    135  0000 ????						; IN 2: absolute address
    136  0000 ????
    137  0000 ????				      MAC	set_pointer
    138  0000 ????			   .POINTER   SET	{1}
    139  0000 ????			   .ADDRESS   SET	{2}
    140  0000 ????
    141  0000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    142  0000 ????				      STA	.POINTER	; Store in pointer
    143  0000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    144  0000 ????				      STA	.POINTER+1	; Store in pointer+1
    145  0000 ????
    146  0000 ????				      ENDM
    147  0000 ????
    148  0000 ????						;-------------------------------------------------------
    149  0000 ????						; BOUNDARY byte#
    150  0000 ????						; Original author: Denis Debro (borrowed from Bob Smith / Thomas)
    151  0000 ????						;
    152  0000 ????						; Push data to a certain position inside a page and keep count of how
    153  0000 ????						; many free bytes the programmer will have.
    154  0000 ????						;
    155  0000 ????						; eg: BOUNDARY 5    ; position at byte #5 in page
    156  0000 ????
    157  0000 ????			   .FREE_BYTES SET	0
    158  0000 ????				      MAC	boundary
    159  0000 ????				      REPEAT	256
    160  0000 ????				      IF	<. % {1} = 0
    161  0000 ????				      MEXIT
    162  0000 ????				      ELSE
    163  0000 ????			   .FREE_BYTES SET	.FREE_BYTES + 1
    164  0000 ????				      .byte	$00
    165  0000 ????				      ENDIF
    166  0000 ????				      REPEND
    167  0000 ????				      ENDM
    168  0000 ????
    169  0000 ????
    170  0000 ????						; EOF
------- FILE D:\src\u\s\emu\tests\bins\8blit\8blit-s04e02-Paddle-Controllers-Purrballs.asm
------- FILE build.h LEVEL 2 PASS 2
      0  0000 ????				      include	"build.h"
      1  0000 ????	       00 25	   VBLANKLINES =	37
      2  0000 ????	       00 58	   VOUTLINES  =	88	; height of our 2lk kernel playfield 192/2
      3  0000 ????	       00 1e	   OVERSCANLINES =	30
      4  0000 ????	       00 0f	   PFSEGHEIGHT =	%00001111	; pf segements are 4 kernel lines in height
      5  0000 ????
      6  0000 ????						; calculate timings
      7  0000 ????	       00 2b	   VBLANKTIME =	(VBLANKLINES * 76) / 64
      8  0000 ????	       00 23	   OVERSCANTIME =	(OVERSCANLINES * 76) / 64
      9  0000 ????
     10  0000 ????	       00 46	   RED	      =	$46
     11  0000 ????	       00 3c	   ORANGE     =	$3c
     12  0000 ????	       00 1e	   YELLOW     =	$1e
     13  0000 ????	       00 a6	   BLUE       =	$a6
     14  0000 ????	       00 0e	   WHITE      =	$0e
     15  0000 ????
------- FILE D:\src\u\s\emu\tests\bins\8blit\8blit-s04e02-Paddle-Controllers-Purrballs.asm
     22  0000 ????
     23  0000 ????						; compiler symbols
     24  0000 ????						;--------------------------------------
     25  0000 ????	       00 05	   PADDLE_POS =	5
     26  0000 ????	       00 0f	   SOUTLINES  =	15
     27  0000 ????	       00 4b	   MISSILE_YPOS =	75
     28  0000 ????	       00 2b	   MISSILE0_XPOS =	43
     29  0000 ????	       00 74	   MISSILE1_XPOS =	116
     30  0000 ????	       00 1e	   SHOWEARS_LEN =	30
     31  0000 ????
     32 U0099 ????				      seg.u	vars	;	  uninitialized segment
     33 U0080					      org	$80	;	  origin set at base of ram 
     34 U0080
     35 U0080							; define variables
     36 U0080		       00	   pf_segment ds	1
     37 U0081		       00	   pf_segindex ds	1
     38 U0082		       00 00	   m_y	      ds	2	;	  missile y pos
     39 U0084		       00	   p_x	      ds	1
     40 U0085		       00 00	   mBearing   ds	2	;	  (0-15) 16 angles 22.5 deg apart
     41 U0087		       00 00	   mBearingOld ds	2	;	  org bearing of ball before bounce
     42 U0089		       00 00	   collisionCnt ds	2	;	  collision count
     43 U008b		       00	   pfCnt      ds	1	;	  playfield index
     44 U008c		       00	   scoreCnt   ds	1	;
     45 U008d		       00	   mCollision ds	1	;	  current players collision register value
     46 U008e		       00	   r_seed     ds	1	;	  random seed
     47 U008f		       00 00	   snd_on     ds	2	;	  1 byte per channel - >0 if sound is playing
     48 U0091		       00	   score      ds	1	;	  value to display
     49 U0092		       00 00	   digitIdx   ds	2	;	  index for digit to use within the data table
     50 U0094		       00	   temp       ds	1	;	  general temp address to swap out values
     51 U0095		       00	   voutCount  ds	1	;	  number of cycles left for vout
     52 U0096		       00	   soutCount  ds	1	;	  number of cycles left for sount (the score)
     53 U0097		       00	   showEarsCnt ds	1	;	  the number of frames left to show the ears
     54 U0098
     55 U0098		       00	   pValue     ds	1	;	  the horizontal position of the paddle
     56 U0099
     57 U0099							; code
     58 U0099							;--------------------------------------
     59  10000 ????				       seg	main	;	  start of main segment
     60  f000					      org	$F000
     61  f000
     62  f000				   reset
      0  f000					      CLEAN_START		;	  ouput: all ram/registers 0
      1  f000		       78		      sei
      2  f001		       d8		      cld
      3  f002
      4  f002				  -	      IFNCONST	NO_ILLEGAL_OPCODES
      5  f002				  -	      lxa	#0
      6  f002					      ELSE
      7  f002		       a2 00		      ldx	#0
      8  f004		       8a		      txa
      9  f005					      ENDIF
     10  f005		       a8		      tay
     11  f006		       ca	   .CLEAR_STACK dex
     12  f007		       9a		      txs
     13  f008		       48		      pha
     14  f009		       d0 fb		      bne	.CLEAR_STACK
     15  f00b
     64  f00b
     65  f00b							; generate a random seed from the interval timer
     66  f00b		       ad 84 02 	      lda	INTIM	;	  unknown value to use as an initial random seed
     67  f00e		       85 8e		      sta	r_seed
     68  f010
     69  f010		       a9 17		      lda	#%00010111	;	  missiles and player double wide
     70  f012		       85 04		      sta	NUSIZ0	;	  p0+m0
     71  f014		       85 05		      sta	NUSIZ1	;	  p1+m1
     72  f016
     73  f016							; set area values
     74  f016		       a9 15		      lda	#%00010101	;	  playfield to reflect 
     75  f018		       85 0a		      sta	CTRLPF
     76  f01a
     77  f01a				   softReset
     78  f01a
     79  f01a
     80  f01a		       a9 00		      lda	#0
     81  f01c		       85 91		      sta	score	;	  reset the score
     82  f01e		       85 97		      sta	showEarsCnt
     83  f020
     84  f020		       a9 4b		      lda	#MISSILE_YPOS
     85  f022		       85 82		      sta	m_y
     86  f024		       85 83		      sta	m_y+1
     87  f026
     88  f026		       a2 00		      ldx	#0
     89  f028		       a9 2b		      lda	#MISSILE0_XPOS	;	  m0 horizontal position pulling 0 from x
     90  f02a		       20 13 f2 	      jsr	initObject	;	  m0 starting position
     91  f02d
     92  f02d		       a2 01		      ldx	#1
     93  f02f		       a9 74		      lda	#MISSILE1_XPOS	;	  m1 horizontal position
     94  f031		       20 13 f2 	      jsr	initObject	;	  m1 starting position
     95  f034
     96  f034		       a9 3c		      lda	#60	;	  middle screen
     97  f036		       a2 00		      ldx	#0	;	  p0
     98  f038		       20 2d f2 	      jsr	PositionX	;	  set horizontal position
     99  f03b
    100  f03b							; lock the graphic object positions
    101  f03b		       85 02		      sta	WSYNC
    102  f03d							; ---------------------
    103  f03d
    104  f03d		       85 2a		      sta	HMOVE	;	  strobe horizontal move to set fine positions	
    105  f03f
    106  f03f		       a9 00		      lda	#0
    107  f041		       85 20		      sta	HMP0	;	  clear p0 h movement
    108  f043		       85 21		      sta	HMP1	;	  clear p1 h movement
    109  f045		       85 81		      sta	pf_segindex	;	  first index of current playfield segment
    110  f047
    111  f047		       a9 1e		      lda	#YELLOW
    112  f049		       85 06		      sta	COLUP0
    113  f04b		       a9 a6		      lda	#BLUE
    114  f04d		       85 07		      sta	COLUP1
    115  f04f
    116  f04f				   nextFrame
      0  f04f					      VERTICAL_SYNC		;	  output: a = 0; 3 scanlines
      1  f04f		       a9 0e		      lda	#%1110
      2  f051		       85 02	   .VSLP1     sta	WSYNC
      3  f053		       85 00		      sta	VSYNC
      4  f055		       4a		      lsr
      5  f056		       d0 f9		      bne	.VSLP1
    118  f058
    119  f058				   verticalBlank
    120  f058		       a2 2b		      ldx	#VBLANKTIME	;	  defined/precalculated in build.h
    121  f05a		       8e 96 02 	      stx	TIM64T	;	  set 64-clock for 43 intervals. 
    122  f05d
    123  f05d		       a5 98		      lda	pValue	;	  number of scanlines before paddle charged
    124  f05f		       69 01		      adc	#1	;	  wall thickness
    125  f061		       c9 7e		      cmp	#126	;	  farthest hpos for paddle
    126  f063		       10 01		      bpl	pos	;	  check if we're at the end
    127  f065		       2c		      .byte.b	$2c	;	  jump forward 2 bytes	(skips lda #126)
    128  f066				   pos
    129  f066		       a9 7e		      lda	#126
    130  f068		       a2 00		      ldx	#0
    131  f06a		       20 2d f2 	      jsr	PositionX	;	  set paddle position
    132  f06d
    133  f06d							; calculate the score
    134  f06d		       a5 91		      lda	score	; 2	  get the score   
    135  f06f		       18		      clc		; 2	  clear the carry bit so it's not added in adc 
    136  f070		       48		      pha		; 3	  push the score to the stack 
    137  f071		       29 0f		      and	#$0f	; 2	  mask the first nibble 
    138  f073		       85 94		      sta	temp	; 3	  store the first nibble in temp
    139  f075		       0a		      asl		; 2	  shift left (multiply by 2)
    140  f076		       0a		      asl		; 2	  shift left (multiply by 2)
    141  f077		       65 94		      adc	temp	; 2	  add the first nibble to the result 
    142  f079		       85 92		      sta	digitIdx	; 3	  store calculated index
    143  f07b		       68		      pla		; 4	  pull original score from stack
    144  f07c		       29 f0		      and	#$f0	; 2	  mask the second nibble
    145  f07e		       4a		      lsr		; 2	  shift right (divide by 2)
    146  f07f		       4a		      lsr		; 2	  shift right (divide by 2)
    147  f080		       85 94		      sta	temp	; 3	  store calculated index
    148  f082		       4a		      lsr		; 2	  shift right (divide by 2)
    149  f083		       4a		      lsr		; 2	  shift right (divide by 2)
    150  f084		       65 94		      adc	temp	; 2	  add 
    151  f086		       85 93		      sta	digitIdx+1	; 3	  store the index in the address digitIdx+1.  
    152  f088
    153  f088							; process the sound channels to turn off volume when counter runs out
    154  f088		       20 72 f2 	      jsr	snd_process
    155  f08b
    156  f08b							; we're checking the collision between m0+pf, m1+pf, and m1+m2
    157  f08b		       a2 01		      ldx	#1	;	  start with m1 and work down to m0
    158  f08d				   nextCollObject
    159  f08d
    160  f08d							; collision detection
    161  f08d		       b5 00		      lda	CXM0P,X	;	  missile collision with player 
    162  f08f		       15 04		      ora	CXM0FB,x	;	  missile collision with playfield?
    163  f091		       85 8d		      sta	mCollision
    164  f093		       a9 c0		      lda	#%11000000
    165  f095		       25 8d		      and	mCollision
    166  f097		       d0 07		      bne	collision
    167  f099		       a9 00		      lda	#0	;	  no collision, set collision count to 0
    168  f09b		       95 89		      sta	collisionCnt,x
    169  f09d		       4c ec f0 	      jmp	no_collision	;	  bypass collision handling
    170  f0a0
    171  f0a0							; when a collision occures we try to reflect to a vertical bearing. If on the
    172  f0a0							; next frame we're still registering a collision then we try a horizontal 
    173  f0a0							; bearing. If it's STILL registering a collision then we reflect it back 180
    174  f0a0							; degrees from the original pre-bounce bearing.
    175  f0a0
    176  f0a0				   collision
    177  f0a0							; a collision occured
    178  f0a0		       b5 89		      lda	collisionCnt,x	;	  times collision occured consecutively
    179  f0a2		       d0 30		      bne	col_on	;	  branch if collisions are already ongoing
    180  f0a4
    181  f0a4		       b5 04		      lda	CXM0FB,x
    182  f0a6		       29 c0		      and	#%11000000
    183  f0a8		       f0 03		      beq	doneM0FB
    184  f0aa		       20 3f f2 	      jsr	sndPlayBounce	;	  missile collision with pf
    185  f0ad				   doneM0FB
    186  f0ad		       b5 00		      lda	CXM0P,X	;	  missile collision with player
    187  f0af		       29 c0		      and	#%11000000
    188  f0b1		       f0 0c		      beq	doneM0P
    189  f0b3		       f8		      sed		;	  set decimal flag
    190  f0b4		       18		      clc
    191  f0b5		       a5 91		      lda	score
    192  f0b7		       69 01		      adc	#1
    193  f0b9		       85 91		      sta	score
    194  f0bb		       d8		      cld		;	  clear decimal flag
    195  f0bc		       20 61 f2 	      jsr	sndPlayPaddle
    196  f0bf				   doneM0P
    197  f0bf		       b5 85		      lda	mBearing,x	;	  get the current bearing
    198  f0c1		       95 87		      sta	mBearingOld,x	;	  store current mBearing
    199  f0c3		       49 ff		      eor	#$FF	;	  reverse our bearings 
    200  f0c5		       95 85		      sta	mBearing,x
    201  f0c7		       f6 85		      inc	mBearing,x	;	  additive reverse
    202  f0c9		       b5 85		      lda	mBearing,x
    203  f0cb		       29 03		      and	#$03	;	  is bearing N,S,E,W?
    204  f0cd		       d0 02		      bne	col_no_adj
    205  f0cf		       f6 85		      inc	mBearing,x	;	  inc bearing offset to prevent cont reflection
    206  f0d1
    207  f0d1				   col_no_adj
    208  f0d1		       4c ea f0 	      jmp	collision_done
    209  f0d4
    210  f0d4				   col_on
    211  f0d4		       c9 01		      cmp	#$01	;	  check collisionCnt
    212  f0d6		       f0 0b		      beq	revBearing	;	  first collision in series
    213  f0d8		       c9 03		      cmp	#$03	;	  check collisionCnt
    214  f0da		       90 0e		      bcc	collision_done	;	  second/third collision in series
    215  f0dc		       d0 0c		      bne	collision_done	;	  more than three collisions in series
    216  f0de		       b5 87		      lda	mBearingOld,x	;	  retrieve pre-bounce bearing
    217  f0e0		       4c e5 f0 	      jmp	revOrgBearing	;	  reverse bearing it 180 degrees
    218  f0e3
    219  f0e3				   revBearing		;	  reverse altered bearing
    220  f0e3		       b5 85		      lda	mBearing,x
    221  f0e5				   revOrgBearing		;	  reverse original bearing
    222  f0e5		       18		      clc		;	  clear carry so not included in adc
    223  f0e6		       69 08		      adc	#$08	;	  reverse bearing by 180 degrees
    224  f0e8		       95 85		      sta	mBearing,x
    225  f0ea
    226  f0ea				   collision_done
    227  f0ea		       f6 89		      inc	collisionCnt,x	;	  increment the number of consecutive collisions
    228  f0ec				   no_collision
    229  f0ec
    230  f0ec		       20 f2 f1 	      jsr	moveBall
    231  f0ef
    232  f0ef		       ca		      dex		;	  check next object
    233  f0f0		       10 9b		      bpl	nextCollObject	;	  when result is positive move on to p0
    234  f0f2
    235  f0f2		       a0 ff		      ldy	#255	;	  prime for first playfield segment 
    236  f0f4		       84 80		      sty	pf_segment
    237  f0f6		       a2 58		      ldx	#VOUTLINES	;	  defined in build.h
    238  f0f8		       86 8b		      stx	pfCnt	;	  2 line kernel (2lk) so count is 1/2 pf height
    239  f0fa
    240  f0fa		       85 02		      sta	WSYNC
    241  f0fc							; ---------------------
    242  f0fc
    243  f0fc		       85 2a		      sta	HMOVE	;	  set fine horizontal positioning
    244  f0fe		       85 2c		      sta	CXCLR	;	  clear all the collision registers
    245  f100
    246  f100		       a9 0f		      lda	#SOUTLINES	; 2	
    247  f102		       85 96		      sta	soutCount	; 3	      
    248  f104
    249  f104				   checktimer
    250  f104		       ad 84 02 	      lda	INTIM	;	  time remaining (or past)
    251  f107		       d0 fb		      bne	checktimer	;	  burn remaining cycles
    252  f109
    253  f109		       85 02		      sta	WSYNC
    254  f10b							; ---------------------
    255  f10b		       a9 80		      lda	#%10000000	; 2	  dump paddle + vertical blank off
    256  f10d		       85 01		      sta	VBLANK	; 3
    257  f10f
    258  f10f
    259  f10f		       a5 97		      lda	showEarsCnt
    260  f111		       f0 1b		      beq	showScore
    261  f113		       a2 04		      ldx	#$4
    262  f115		       a9 46		      lda	#RED
    263  f117		       85 08		      sta	COLUPF
    264  f119				   showEars
    265  f119		       bd 11 f3 	      lda	ears,x
    266  f11c		       85 0e		      sta	PF1
    267  f11e		       85 02		      sta	WSYNC
    268  f120							; ---------------------
    269  f120
    270  f120		       85 02		      sta	WSYNC
    271  f122							; ---------------------
    272  f122
    273  f122		       85 02		      sta	WSYNC
    274  f124							; ---------------------
    275  f124
    276  f124		       ca		      dex
    277  f125		       10 f2		      bpl	showEars
    278  f127		       c6 97		      dec	showEarsCnt
    279  f129
    280  f129		       85 02		      sta	WSYNC
    281  f12b							; ---------------------
    282  f12b
    283  f12b		       4c 6f f1 	      jmp	charge
    284  f12e
    285  f12e
    286  f12e				   showScore
    287  f12e		       a0 03		      ldy	#$3
    288  f130		       a9 0e		      lda	#WHITE
    289  f132		       85 08		      sta	COLUPF
    290  f134				   voutscore
    291  f134		       a6 92		      ldx	digitIdx	; 2
    292  f136		       bd 74 f3 	      lda	digits,x	; 2	  load the digit graphic for this scanline     
    293  f139		       29 0f		      and	#$0f	; 2	  mask off first nibble so only see one number
    294  f13b		       85 94		      sta	temp	; 3
    295  f13d		       a6 93		      ldx	digitIdx+1	; 2
    296  f13f		       bd 74 f3 	      lda	digits,x	; 2
    297  f142		       29 f0		      and	#$f0	; 2
    298  f144		       05 94		      ora	temp	; 2
    299  f146		       a2 00		      ldx	#$0	; 2	  PF1 is displayed. clear before it repeats
    300  f148		       86 0e		      stx	PF1	; 3
    301  f14a		       88		      dey		; 2
    302  f14b		       85 02		      sta	WSYNC	; 3
    303  f14d							; ---------------------
    304  f14d
    305  f14d		       d0 06		      bne	cont	; 2/3
    306  f14f		       a0 03		      ldy	#3	; 2
    307  f151		       e6 92		      inc	digitIdx	; 2	  inc digit offset to get next line of graphic
    308  f153		       e6 93		      inc	digitIdx+1	; 2
    309  f155				   cont
    310  f155		       85 0e		      sta	PF1	; 3	  write the digit graphic to the playfield
    311  f157		       c6 96		      dec	soutCount	; 5
    312  f159		       d0 d9		      bne	voutscore	; 2/3	       
    313  f15b
      0  f15b					      SLEEP	20	; 20	  we need some padding before clearing PF1	   
      1  f15b				   .CYCLES    SET	20
      2  f15b
      3  f15b				  -	      IF	.CYCLES < 2
      4  f15b				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  f15b				  -	      ERR
      6  f15b					      ENDIF
      7  f15b
      8  f15b				  -	      IF	.CYCLES & 1
      9  f15b				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  f15b				  -	      nop	0
     11  f15b				  -	      ELSE
     12  f15b				  -	      bit	VSYNC
     13  f15b				  -	      ENDIF
     14  f15b				  -.CYCLES    SET	.CYCLES - 3
     15  f15b					      ENDIF
     16  f15b
     17  f15b					      REPEAT	.CYCLES / 2
     18  f15b		       ea		      nop
     17  f15b					      REPEND
     18  f15c		       ea		      nop
     17  f15c					      REPEND
     18  f15d		       ea		      nop
     17  f15d					      REPEND
     18  f15e		       ea		      nop
     17  f15e					      REPEND
     18  f15f		       ea		      nop
     17  f15f					      REPEND
     18  f160		       ea		      nop
     17  f160					      REPEND
     18  f161		       ea		      nop
     17  f161					      REPEND
     18  f162		       ea		      nop
     17  f162					      REPEND
     18  f163		       ea		      nop
     17  f163					      REPEND
     18  f164		       ea		      nop
     19  f165					      REPEND
    315  f165
    316  f165		       a9 00		      lda	#$0	; 2
    317  f167		       85 0e		      sta	PF1	; 3	  clear PF1  
    318  f169
    319  f169		       a9 46		      lda	#RED
    320  f16b		       85 08		      sta	COLUPF
    321  f16d		       85 02		      sta	WSYNC	; 3
    322  f16f							; ---------------------
    323  f16f
    324  f16f				   charge
    325  f16f		       a9 00		      lda	#%00000000	; 2	  charge paddle
    326  f171		       85 01		      sta	VBLANK	; 3
    327  f173				   vout
    328  f173
    329  f173		       a6 8b		      ldx	pfCnt
    330  f175		       2a		      rol
    331  f176		       aa		      tax
    332  f177		       a5 09		      lda	INPT1	; 2	  check paddle 0
    333  f179		       10 01		      bpl	donep0	; 2/3	  0=charging, 1=charged
    334  f17b		       2c		      .byte.b	$2c	; 4	  jumps 2 bytes ahead (bypassing the stx pValue)
    335  f17c				   donep0
    336  f17c		       86 98		      stx	pValue	; 3	  store current scanline value
    337  f17e
    338  f17e		       46 81		      lsr	pf_segindex	; 5	5 
    339  f180		       d0 06		      bne	skipx	; 3	8 
    340  f182		       e6 80		      inc	pf_segment	; 5   13
    341  f184		       a2 0f		      ldx	#PFSEGHEIGHT	; 2   15      
    342  f186		       86 81		      stx	pf_segindex	; 3   18
    343  f188				   skipx
    344  f188		       a4 80		      ldy	pf_segment	; 2   20
    345  f18a		       b9 18 f3 	      lda	PF0_data_cat,y	; 4   24 
    346  f18d		       85 02		      sta	WSYNC	; 3   27	    
    347  f18f							; ---------------------
    348  f18f
    349  f18f
    350  f18f
    351  f18f							; draw playfield
    352  f18f		       85 0d		      sta	PF0	; 3   29
    353  f191		       b9 30 f3 	      lda	PF1_data_cat,y	; 4   34
    354  f194		       85 0e		      sta	PF1	; 3   37
    355  f196		       b9 48 f3 	      lda	PF2_data_cat,y	; 4   41
    356  f199		       85 0f		      sta	PF2	; 3   44
    357  f19b		       a9 3c		      lda	#ORANGE	; 2   46 defined in build.h 
    358  f19d		       85 09		      sta	COLUBK	; 3   49
    359  f19f
    360  f19f		       a0 00		      ldy	#0	; 2   51
    361  f1a1		       a2 00		      ldx	#0
    362  f1a3		       b9 82 00 	      lda	m_y,y	; 4   57 load ball y pos
    363  f1a6		       c5 8b		      cmp	pfCnt	; 2   59 compare y pos to playfield counter
    364  f1a8		       d0 02		      bne	noM1	; 3   62 if not same continue with blank player graphic
    365  f1aa		       a2 02		      ldx	#%00000010
    366  f1ac				   noM1
    367  f1ac		       96 1d		      stx	ENAM0,y	; 4   70 enable missile
    368  f1ae		       a2 00		      ldx	#0
    369  f1b0		       c8		      iny
    370  f1b1		       b9 82 00 	      lda	m_y,y	; 4   57 load ball y pos
    371  f1b4		       c5 8b		      cmp	pfCnt	; 2   59 compare y pos to playfield counter
    372  f1b6		       d0 02		      bne	noM0	; 3   62 if not same continue with blank player graphic
    373  f1b8		       a2 02		      ldx	#%00000010
    374  f1ba				   noM0
    375  f1ba		       96 1d		      stx	ENAM0,y	; 4   70 enable missile
    376  f1bc		       85 02		      sta	WSYNC	; 3  149
    377  f1be							; ---------------------
    378  f1be
    379  f1be
    380  f1be		       a2 00		      ldx	#0	; 2  151
    381  f1c0		       a5 8b		      lda	pfCnt	; 3  154
    382  f1c2		       c9 05		      cmp	#PADDLE_POS	; 2  156
    383  f1c4		       10 03		      bpl	noP0	;2/3 159
    384  f1c6		       ae 00 f3 	      ldx	paddle	; 3  162
    385  f1c9				   noP0
    386  f1c9		       86 1b		      stx	GRP0	; 3  165
    387  f1cb
    388  f1cb		       c6 8b		      dec	pfCnt	; 5  170
    389  f1cd		       d0 a4		      bne	vout	;2/3 173
    390  f1cf
    391  f1cf		       85 02		      sta	WSYNC	;	  end kernel with a clean scan line
    392  f1d1							; ---------------------
    393  f1d1
    394  f1d1		       a9 02		      lda	#$2	;	  set D1 = 1 to initiate VBLANK
    395  f1d3		       85 01		      sta	VBLANK	;	  turn off the beam
    396  f1d5
    397  f1d5		       a9 00		      lda	#$0
    398  f1d7		       85 0d		      sta	PF0
    399  f1d9		       85 0e		      sta	PF1
    400  f1db		       85 0f		      sta	PF2
    401  f1dd		       85 09		      sta	COLUBK
    402  f1df		       85 1d		      sta	ENAM0
    403  f1e1		       85 1e		      sta	ENAM1
    404  f1e3		       85 1b		      sta	GRP0
    405  f1e5
    406  f1e5							; ---- overscan (30 scanlines)
    407  f1e5		       a2 23		      ldx	#OVERSCANTIME	;	  
    408  f1e7		       8e 96 02 	      stx	TIM64T	;	  Set a count of 35 with 64-clock interval
    409  f1ea
    410  f1ea							; overscan remainder timer -----------
    411  f1ea				   overscan_timer
    412  f1ea		       ae 84 02 	      ldx	INTIM
    413  f1ed		       d0 fb		      bne	overscan_timer
    414  f1ef		       4c 4f f0 	      jmp	nextFrame	;	  jump back up to start the next frame
    415  f1f2
    416  f1f2				   moveBall   subroutine
    417  f1f2							; move the ball
    418  f1f2		       b5 85		      lda	mBearing,x
    419  f1f4		       29 0f		      and	#$0F	;	  strip the high nibble
    420  f1f6		       a8		      tay
    421  f1f7		       b9 01 f3 	      lda	bearingOffset,y	;	  load x/y offsets based on the current bearing
    422  f1fa		       95 22		      sta	HMM0,x	;	  horizontally move the current missile object
    423  f1fc							;	  update balls horizontal motion register which
    424  f1fc							;	  uses the high nibble where the x offset is
    425  f1fc							;	  stored.
    426  f1fc		       29 0f		      and	#$0F	;	  strip out high nibble which leave only offset
    427  f1fe		       38		      sec		;	  set the carry flag
    428  f1ff		       e9 08		      sbc	#$08	;	  subtract 8 for 4bit 2's completment +/-
    429  f201		       18		      clc		;	  clear carry flag so it's not used in adc
    430  f202		       75 82		      adc	m_y,x	;	  add y offset to current y position
    431  f204		       c9 80		      cmp	#128
    432  f206		       90 08		      bcc	ballactive	;	  is the ball still in the playfield?
    433  f208		       20 50 f2 	      jsr	sndPlayRespawn	;	  use the p0/p1 value in x for channel
    434  f20b		       20 13 f2 	      jsr	initObject	;	  respawn the missile
    435  f20e
    436  f20e		       a9 4b		      lda	#MISSILE_YPOS
    437  f210				   ballactive
    438  f210		       95 82		      sta	m_y,x	;	  store the new y position
    439  f212
    440  f212		       60		      rts
    441  f213
    442  f213				   initObject subroutine
    443  f213
    444  f213							; 'randomly' select an initial bearing (direction)
    445  f213		       20 23 f2 	      jsr	galoisLfsrRand	;	  no need to store the seed for this one
    446  f216		       29 0f		      and	#$0F	;	  limit the value to 0-15
    447  f218		       95 85		      sta	mBearing,x
    448  f21a		       a9 1e		      lda	#SHOWEARS_LEN
    449  f21c		       85 97		      sta	showEarsCnt
    450  f21e		       a9 00		      lda	#0
    451  f220		       85 91		      sta	score	;	  reset score
    452  f222		       60		      rts
    453  f223
    454  f223							; Galois 8-bit Linear Feedback Shift Registers
    455  f223							; https://samiam.org/blog/20130617.html
    456  f223				   galoisLfsrRand subroutine
    457  f223		       a5 8e		      lda	r_seed	;	  keep calling funtion to for better entropy
    458  f225		       4a		      lsr		;	  shift right
    459  f226		       90 02		      bcc	.noeor0	;	  if carry 1, then exclusive OR the bits
    460  f228		       49 d4		      eor	#$D4	;	  d4 tap (11010100)
    461  f22a				   .noeor0
    462  f22a		       85 8e		      sta	r_seed
    463  f22c		       60		      rts
    464  f22d
    465  f22d							; -----------------------------------------------------------------------------
    466  f22d							; PositionX
    467  f22d							; A - Horizontal position of the object
    468  f22d							; X - Object to position
    469  f22d							;   0 - Player 0
    470  f22d							;   1 - Player 1
    471  f22d							;   2 - Missile 0
    472  f22d							;   3 - Missile 1
    473  f22d							;   4 - Ball
    474  f22d							; -----------------------------------------------------------------------------
    475  f22d
    476  f22d				   PositionX  subroutine
    477  f22d		       38		      sec		; 2	2 set the carry flag
    478  f22e		       85 02		      sta	WSYNC	; 3	5 start a new line
    479  f230							; ---------------------
    480  f230
    481  f230				   .divide
    482  f230		       e9 0f		      sbc	#15	; 2	2 subtract 15
    483  f232		       b0 fc		      bcs	.divide	; 2	4 branch until negative
    484  f234		       49 07		      eor	#7	; 2	6 calculate fine offset
    485  f236		       0a		      asl		; 2	8 shift left
    486  f237		       0a		      asl		; 2   10
    487  f238		       0a		      asl		; 2   12
    488  f239		       0a		      asl		; 2   14
    489  f23a		       95 20		      sta	HMP0,x	; 5   19 set fine offset
    490  f23c		       95 10		      sta	RESP0,x	; 4   23 set coarse position
    491  f23e		       60		      rts		; 6   29 return
    492  f23f
    493  f23f							; cues a sound to play. sets audio registers based on table lookup sndbank.
    494  f23f							; parameters: x = channel (0|1), y = sound to play
    495  f23f				   sndPlayBounce
    496  f23f		       a9 0c		      lda	#$0C
    497  f241		       85 15		      sta	AUDC0	;	  audio control   
    498  f243		       a9 05		      lda	#$05
    499  f245		       85 19		      sta	AUDV0	;	  audio volume
    500  f247		       a9 0f		      lda	#$0F
    501  f249		       85 17		      sta	AUDF0	;	  audio frequence
    502  f24b		       a9 01		      lda	#01
    503  f24d		       85 8f		      sta	snd_on	;	  len of audio in frames (>0 = sound on)
    504  f24f		       60		      rts
    505  f250
    506  f250				   sndPlayRespawn
    507  f250		       a9 02		      lda	#$02
    508  f252		       85 16		      sta	AUDC1	;	  audio control   
    509  f254		       a9 14		      lda	#$14
    510  f256		       85 1a		      sta	AUDV1	;	  audio volume
    511  f258		       a9 05		      lda	#$05
    512  f25a		       85 18		      sta	AUDF1	;	  audio frequence
    513  f25c		       a9 14		      lda	#20
    514  f25e		       85 90		      sta	snd_on+1	;	  len of audio in frames (>0 = sound on)
    515  f260		       60		      rts
    516  f261
    517  f261				   sndPlayPaddle
    518  f261		       a9 0e		      lda	#$0E
    519  f263		       85 15		      sta	AUDC0	;	  audio control   
    520  f265		       a9 05		      lda	#$05
    521  f267		       85 19		      sta	AUDV0	;	  audio volume
    522  f269		       a9 03		      lda	#$03
    523  f26b		       85 17		      sta	AUDF0	;	  audio frequence
    524  f26d		       a9 04		      lda	#04
    525  f26f		       85 8f		      sta	snd_on	;	  len of audio in frames (>0 = sound on)
    526  f271		       60		      rts
    527  f272
    528  f272							; process sound channels to turn off volume when sound length counter runs out
    529  f272				   snd_process
    530  f272		       a2 01		      ldx	#1	;	  channel to process, start with channel 1
    531  f274				   snd_ch
    532  f274		       b5 8f		      lda	snd_on,x	;	  get sound length counter for this channel
    533  f276		       f0 08		      beq	snd_done	;	  are we playing a sound? a>1 
    534  f278		       d6 8f		      dec	snd_on,x	;	  yes, decrese the sound length counter for channel
    535  f27a		       d0 04		      bne	snd_cont	;	  did we reach the end of the sound length?
    536  f27c		       a9 00		      lda	#0	;	  yes
    537  f27e		       95 19		      sta	AUDV0,x	;	  turn off the volume for this channel 
    538  f280				   snd_done
    539  f280				   snd_cont
    540  f280		       ca		      dex		;	  do it again for channel 0
    541  f281		       f0 f1		      beq	snd_ch
    542  f283		       60		      rts
    543  f284
    544  f300		       00 00 00 00*	      align	$100	;	  align data
    545  f300
    546  f300				   paddle
    547  f300		       ff		      .byte.b	#%11111111
    548  f301
    549  f301				   bearingOffset		;	  index  x-move  y-move
    550  f301		       e0		      .byte.b	#%11100000	;	    0	  -2	   0	
    551  f302		       e7		      .byte.b	#%11100111	;	    1	  -2	  -2	
    552  f303		       e6		      .byte.b	#%11100110	;	    2	  -2	  -4	
    553  f304		       f6		      .byte.b	#%11110110	;	    3	  -1	  -4	
    554  f305		       06		      .byte.b	#%00000110	;	    4	   0	  -4	
    555  f306		       16		      .byte.b	#%00010110	;	    5	  +1	  -4	
    556  f307		       26		      .byte.b	#%00100110	;	    6	  +2	  -4	
    557  f308		       27		      .byte.b	#%00100111	;	    7	  +2	  -2	
    558  f309		       28		      .byte.b	#%00101000	;	    8	  +2	   0	
    559  f30a		       29		      .byte.b	#%00101001	;	    9	  +2	  +2	
    560  f30b		       2a		      .byte.b	#%00101010	;	   10	  +2	  +4	
    561  f30c		       1a		      .byte.b	#%00011010	;	   11	  +1	  +4	
    562  f30d		       09		      .byte.b	#%00001001	;	   12	   0	  +2	
    563  f30e		       fa		      .byte.b	#%11111010	;	   13	  -1	  +4	
    564  f30f		       ea		      .byte.b	#%11101010	;	   14	  -2	  +4	
    565  f310		       e9		      .byte.b	#%11101001	;	   15	  -2	  +2  
    566  f311
    567  f311				   ears
    568  f311		       f9		      .byte.b	%11111001
    569  f312		       fa		      .byte.b	%11111010
    570  f313		       74		      .byte.b	%01110100
    571  f314		       28		      .byte.b	%00101000
    572  f315		       18		      .byte.b	%00011000
    573  f316
------- FILE playfields/pf_cat.h LEVEL 2 PASS 2
      0  f316					      include	"playfields/pf_cat.h"
      1  f316				   PF_col_cat
      2  f316		       46		      .byte.b	#$46	; foreground
      3  f317		       00		      .byte.b	#$00	; background
      4  f318
      5  f318				   PF0_data_cat
      6  f318		       f0		      .byte.b	#%11110000	;<- first
      7  f319		       10		      .byte.b	#%00010000
      8  f31a		       10		      .byte.b	#%00010000
      9  f31b		       10		      .byte.b	#%00010000
     10  f31c		       10		      .byte.b	#%00010000
     11  f31d		       10		      .byte.b	#%00010000
     12  f31e		       10		      .byte.b	#%00010000
     13  f31f		       10		      .byte.b	#%00010000
     14  f320		       10		      .byte.b	#%00010000
     15  f321		       10		      .byte.b	#%00010000
     16  f322		       10		      .byte.b	#%00010000
     17  f323		       10		      .byte.b	#%00010000
     18  f324		       10		      .byte.b	#%00010000
     19  f325		       10		      .byte.b	#%00010000
     20  f326		       10		      .byte.b	#%00010000
     21  f327		       10		      .byte.b	#%00010000
     22  f328		       10		      .byte.b	#%00010000
     23  f329		       10		      .byte.b	#%00010000
     24  f32a		       10		      .byte.b	#%00010000
     25  f32b		       10		      .byte.b	#%00010000
     26  f32c		       10		      .byte.b	#%00010000
     27  f32d		       10		      .byte.b	#%00010000
     28  f32e		       10		      .byte.b	#%00010000
     29  f32f		       10		      .byte.b	#%00010000	;<- last
     30  f330
     31  f330				   PF1_data_cat
     32  f330		       ff		      .byte.b	#%11111111	;<- first
     33  f331		       00		      .byte.b	#%00000000
     34  f332		       00		      .byte.b	#%00000000
     35  f333		       00		      .byte.b	#%00000000
     36  f334		       00		      .byte.b	#%00000000
     37  f335		       00		      .byte.b	#%00000000
     38  f336		       07		      .byte.b	#%00000111
     39  f337		       01		      .byte.b	#%00000001
     40  f338		       00		      .byte.b	#%00000000
     41  f339		       00		      .byte.b	#%00000000
     42  f33a		       60		      .byte.b	#%01100000
     43  f33b		       00		      .byte.b	#%00000000
     44  f33c		       60		      .byte.b	#%01100000
     45  f33d		       00		      .byte.b	#%00000000
     46  f33e		       60		      .byte.b	#%01100000
     47  f33f		       00		      .byte.b	#%00000000
     48  f340		       00		      .byte.b	#%00000000
     49  f341		       00		      .byte.b	#%00000000
     50  f342		       00		      .byte.b	#%00000000
     51  f343		       00		      .byte.b	#%00000000
     52  f344		       00		      .byte.b	#%00000000
     53  f345		       00		      .byte.b	#%00000000
     54  f346		       00		      .byte.b	#%00000000
     55  f347		       00		      .byte.b	#%00000000	;<- last
     56  f348
     57  f348				   PF2_data_cat
     58  f348		       ff		      .byte.b	#%11111111	;<- first
     59  f349		       00		      .byte.b	#%00000000
     60  f34a		       00		      .byte.b	#%00000000
     61  f34b		       00		      .byte.b	#%00000000
     62  f34c		       00		      .byte.b	#%00000000
     63  f34d		       00		      .byte.b	#%00000000
     64  f34e		       01		      .byte.b	#%00000001
     65  f34f		       00		      .byte.b	#%00000000
     66  f350		       00		      .byte.b	#%00000000
     67  f351		       00		      .byte.b	#%00000000
     68  f352		       00		      .byte.b	#%00000000
     69  f353		       80		      .byte.b	#%10000000
     70  f354		       00		      .byte.b	#%00000000
     71  f355		       00		      .byte.b	#%00000000
     72  f356		       00		      .byte.b	#%00000000
     73  f357		       00		      .byte.b	#%00000000
     74  f358		       00		      .byte.b	#%00000000
     75  f359		       00		      .byte.b	#%00000000
     76  f35a		       00		      .byte.b	#%00000000
     77  f35b		       00		      .byte.b	#%00000000
     78  f35c		       00		      .byte.b	#%00000000
     79  f35d		       00		      .byte.b	#%00000000
     80  f35e		       00		      .byte.b	#%00000000
     81  f35f		       00		      .byte.b	#%00000000	;<- last
------- FILE D:\src\u\s\emu\tests\bins\8blit\8blit-s04e02-Paddle-Controllers-Purrballs.asm
------- FILE digits.h LEVEL 2 PASS 2
      0  f360					      include	"digits.h"
      1  f360				   p0
      2  f360		       88		      .byte.b	%10001000
      3  f361		       88		      .byte.b	%10001000
      4  f362		       e8		      .byte.b	%11101000
      5  f363		       a8		      .byte.b	%10101000
      6  f364		       e8		      .byte.b	%11101000
      7  f365				   p1
      8  f365		       8e		      .byte.b	%10001110
      9  f366		       88		      .byte.b	%10001000
     10  f367		       ee		      .byte.b	%11101110
     11  f368		       a2		      .byte.b	%10100010
     12  f369		       ee		      .byte.b	%11101110
     13  f36a				   p2
     14  f36a		       8e		      .byte.b	%10001110
     15  f36b		       82		      .byte.b	%10000010
     16  f36c		       e6		      .byte.b	%11100110
     17  f36d		       a2		      .byte.b	%10100010
     18  f36e		       ee		      .byte.b	%11101110
     19  f36f				   p3
     20  f36f		       82		      .byte.b	%10000010
     21  f370		       82		      .byte.b	%10000010
     22  f371		       ee		      .byte.b	%11101110
     23  f372		       aa		      .byte.b	%10101010
     24  f373		       ea		      .byte.b	%11101010
     25  f374
     26  f374
     27  f374
     28  f374							; 0 to 99 in 50 bytes
     29  f374							; 00 to FF in 75 bytes
     30  f374
     31  f374				   digits
     32  f374							; 00
     33  f374		       77		      .byte.b	%01110111
     34  f375		       55		      .byte.b	%01010101
     35  f376		       55		      .byte.b	%01010101
     36  f377		       55		      .byte.b	%01010101
     37  f378		       77		      .byte.b	%01110111
     38  f379							; 11
     39  f379		       11		      .byte.b	%00010001
     40  f37a		       11		      .byte.b	%00010001
     41  f37b		       11		      .byte.b	%00010001
     42  f37c		       11		      .byte.b	%00010001
     43  f37d		       11		      .byte.b	%00010001
     44  f37e							; 22
     45  f37e		       77		      .byte.b	%01110111
     46  f37f		       11		      .byte.b	%00010001
     47  f380		       77		      .byte.b	%01110111
     48  f381		       44		      .byte.b	%01000100
     49  f382		       77		      .byte.b	%01110111
     50  f383							; 33
     51  f383		       77		      .byte.b	%01110111
     52  f384		       11		      .byte.b	%00010001
     53  f385		       33		      .byte.b	%00110011
     54  f386		       11		      .byte.b	%00010001
     55  f387		       77		      .byte.b	%01110111
     56  f388							; 44
     57  f388		       55		      .byte.b	%01010101
     58  f389		       55		      .byte.b	%01010101
     59  f38a		       77		      .byte.b	%01110111
     60  f38b		       11		      .byte.b	%00010001
     61  f38c		       11		      .byte.b	%00010001
     62  f38d							; 55
     63  f38d		       77		      .byte.b	%01110111
     64  f38e		       44		      .byte.b	%01000100
     65  f38f		       77		      .byte.b	%01110111
     66  f390		       11		      .byte.b	%00010001
     67  f391		       77		      .byte.b	%01110111
     68  f392							; 66
     69  f392		       77		      .byte.b	%01110111
     70  f393		       44		      .byte.b	%01000100
     71  f394		       77		      .byte.b	%01110111
     72  f395		       55		      .byte.b	%01010101
     73  f396		       77		      .byte.b	%01110111
     74  f397							; 77
     75  f397		       77		      .byte.b	%01110111
     76  f398		       11		      .byte.b	%00010001
     77  f399		       11		      .byte.b	%00010001
     78  f39a		       11		      .byte.b	%00010001
     79  f39b		       11		      .byte.b	%00010001
     80  f39c							; 88
     81  f39c		       77		      .byte.b	%01110111
     82  f39d		       55		      .byte.b	%01010101
     83  f39e		       77		      .byte.b	%01110111
     84  f39f		       55		      .byte.b	%01010101
     85  f3a0		       77		      .byte.b	%01110111
     86  f3a1							; 99
     87  f3a1		       77		      .byte.b	%01110111
     88  f3a2		       55		      .byte.b	%01010101
     89  f3a3		       77		      .byte.b	%01110111
     90  f3a4		       11		      .byte.b	%00010001
     91  f3a5		       77		      .byte.b	%01110111
     92  f3a6							; AA
     93  f3a6		       22		      .byte.b	%00100010
     94  f3a7		       55		      .byte.b	%01010101
     95  f3a8		       77		      .byte.b	%01110111
     96  f3a9		       55		      .byte.b	%01010101
     97  f3aa		       55		      .byte.b	%01010101
     98  f3ab							; BB
     99  f3ab		       66		      .byte.b	%01100110
    100  f3ac		       55		      .byte.b	%01010101
    101  f3ad		       66		      .byte.b	%01100110
    102  f3ae		       55		      .byte.b	%01010101
    103  f3af		       66		      .byte.b	%01100110
    104  f3b0							; CC
    105  f3b0		       77		      .byte.b	%01110111
    106  f3b1		       44		      .byte.b	%01000100
    107  f3b2		       44		      .byte.b	%01000100
    108  f3b3		       44		      .byte.b	%01000100
    109  f3b4		       77		      .byte.b	%01110111
    110  f3b5							; DD
    111  f3b5		       66		      .byte.b	%01100110
    112  f3b6		       55		      .byte.b	%01010101
    113  f3b7		       55		      .byte.b	%01010101
    114  f3b8		       55		      .byte.b	%01010101
    115  f3b9		       66		      .byte.b	%01100110
    116  f3ba							; EE
    117  f3ba		       77		      .byte.b	%01110111
    118  f3bb		       44		      .byte.b	%01000100
    119  f3bc		       66		      .byte.b	%01100110
    120  f3bd		       44		      .byte.b	%01000100
    121  f3be		       77		      .byte.b	%01110111
    122  f3bf							; FF
    123  f3bf		       77		      .byte.b	%01110111
    124  f3c0		       44		      .byte.b	%01000100
    125  f3c1		       66		      .byte.b	%01100110
    126  f3c2		       44		      .byte.b	%01000100
    127  f3c3		       44		      .byte.b	%01000100
------- FILE D:\src\u\s\emu\tests\bins\8blit\8blit-s04e02-Paddle-Controllers-Purrballs.asm
    576  f3c4
    577  fffa					      org	$fffa
    578  fffa
    579  fffa		       00 f0		      .word.w	reset	;	  nmi ($fffa)
    580  fffc		       00 f0		      .word.w	reset	;	  reset ($fffc)
    581  fffe		       00 f0		      .word.w	reset	;	  irq ($fffe)
